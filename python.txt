Int   : int()
Float : float()
Str   : str()

==========

піднесення у степінь (**), ділення націло (//) та взяття залишку від ділення (%)

==========

якщо хоч одне із значень у виразі є дійсним числом, для проведення розрахунків інтерпретатору доведеться конвертувати значення, які з ним взаємодіють, і результат також буде дійсним, навіть за відсутності у нього дробової частини.

print (2+2)**2 % 10.0
- виведе 6.0

І навпаки, якщо операнди є цілими, результат також буде цілим. Таким чином, ділення двох цілих чисел фактично також є операцією "ділення націло":

print 10/3
- виведе 3

==========

рядки можна додавати та множити на цілі числа

==========

# однорядковий коментар

"""
багаторядковий коментар
"""

==========

Логічні вирази

a < b   -- дорівнює True, якщо a менше b, інакше -- False,
a <= b  -- дорівнює True, якщо a менше або дорівнює b, інакше -- False,
a == b  -- дорівнює True, якщо a дорівнює b, інакше -- False,
a != b  -- дорівнює True, якщо a не дорівнює b, інакше -- False,
a <> b  --   - - / / - -
a >= b  -- дорівнює True, якщо a більше або дорівнює b, інакше -- False,
a > b   -- дорівнює True, якщо a більше b, інакше -- False.

x or y  -- дорівнює True, якщо хоч 1 з x або y дорівнює True, інакше -- False,
x and y -- дорівнює True, якщо x та y обидва дорівнюють True, інакше -- False,
not x   -- дорівнює True, якщо x не дорівнює True, інакше -- False.

Логічні операції можуть застосовуватися в одному виразі із математичними. При цьому математичні мають вищий пріоритет виконання, отже будуть обраховані раніше.
Першими у виразі обчислюються значення всіх “модифікаторів” not, потім and зліва направо, потім or -- також зліва направо.

==========

Типи даних

Прості:  integer, float, boolean, string
Складні: list,

Список -- складний тип даних, впорядкована послідовність значень будь-яких типів. (Аналог масива в JS)

example_list = ['one', 1, 2.0, True, [0.1, 0.2, 0.3]]
example_list[0] == 'one'
example_list[1] == 1
example_list[4][1] == 0.2
example_list[5] = '5!' # присвоїли значення новому елементу

print len(example_list) # довжина списку

взяття підмасиву

example_list[i:j] -- вибере всі елементи списку з i-го (включно) по j-й (виключаючи),
example_list[i:]  -- вибере всі елементи списку з i-го (включно) до кінця,
example_list[:j]  -- вибере всі елементи списку з початку по j-й (виключаючи).
example_list[i:j:k] -- вибере кожний k-й елемент списку з i-го (включно) по j-й (виключаючи),
example_list[i::k] -- вибере кожний k-й елемент списку з i-го (включно) до кінця,
example_list[:j:k] -- вибере кожний k-й елемент списку з початку по j-й (виключно),
example_list[::k] -- вибере кожний k-й елемент списку.

range(i) -- повертає список з числами від 0 (включно) до i (виключаючи, тобто до і-1),
range(i,j) -- повертає список з числами від i (включно) до j (виключаючи, тобто до j-1),
range(i,j,k) -- повертає список, що містить кожне k-те число від і (включно) до j (виключаючи, тобто до j-1)

Якщо i чи j від’ємні, відлік для них буде проводитися з кінця послідовності (до речі, те саме стосується від’ємних індексів).
k також може бути від’ємним, що призведе до формування нового списку із зворотним порядком елементів.

x.append(y) -- додає значення y в кінець списку x
x.upper() -- змінює регістр всіх символів рядка x на верхній.
x.lower() -- змінює регістр всіх символів рядка x на нижній.
x.replace(substring_old, substring_new) -- замінює всі входження фрагменту substring_old в рядку x на substring_new
x.find(substring) -- повертає позицію входження (індекс першого символу) фрагменту substring в рядку x або -1, якщо фрагмент не знайдено.

isupper(), islower()



None?

==========

Перетворення типів даних

Boolean ->:

int(True) == 1
int(False) == 0
float(True) == 1.0
float(False) == 0.0
str(True) == 'True'
str(False) == 'False'

-> Boolean:

будь-які “непорожні” значення конвертуються в True, будь-які “нульові” -- в False.

bool(None) == False
bool(0) == False
bool(0.0) == False
bool('') == False

bool(1) == True
bool(10) == True
bool(-1.1) == True
bool('False') == True
bool(-100500) == True

