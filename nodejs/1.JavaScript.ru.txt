



Nodejs - пакунок для Sublime (автодоповнення)

Node.js - в першу чергу для веброзробки, не найкращий варіант для створення
десктоп-застосунку на віндовс. Дуже добрий там, де треба підтримувати велику
кількість з'єднань, наприклад чат на 10000 клієнтів, онлайн-ігри

Node.js = рушій V8 + сторонні бібліотеки для роботи з мережею та файловою
системою

при скачуванні корисно завантажити також вихідні файли (Node.js написаний на С++
та JS), в директорії lib будуть бібліотеки та пакунки, написані на JS

c:\Program Files\nodejs>set path Node.js вписує себе в PATH


Використання на ПК:
-------------------
1. Рідко і для простого. В консолі набрати "node" і почати говнокодити. Вийти з
   режиму - ctrl+C. Режим називається "repl"
2. Основний спосіб. Створити файл file.js і запустити його через консоль
   командою node file.js


Підключення модулів:
--------------------
require('./file.js'); / require('./file');

У модулів Node.js нема спільної області видимості. Для передачі даних з одного
модуля у інший, використовується об'єкт exports, а ті дані, які потрібно
передати, прописуються властивостями цього об'єкту. Цей об'єкт стає резутьтатом
виклику require() в іншому модулі.

у файлі-донорі:
  exports.key = value;

У модулі-акцепторі цей об'єкт є результатом виклику функції require(), тобто для
отримання доступу до даних потрібна змінна:

у файлі-акцепторі:
  let someData = require('./file.js');
  alert(someData.key)                  // value

Для створення глобальних змінних без потреби використовувати об'єкт exports:

у файлі-донорі:
global.key = value;     // global замість window

у файлі-акцепторі:
  require('./file.js'); // результат виклику можна не вписувати у змінну, бо
                        // знінні все-одно глобальні
  alert(key)            // value - змінна доступна напряму, як змінна, а не
                        // властивість об'єкту


Типи модулів:
-------------
1. file.js
2. file.node - компіляція файла на C++, потрібні для високої продуктивності або
   для звернення до тих функцій компа, до яких не можна достукатися через js
3. file.json (не вимагає exports?)
4. dir/index


Порядок пошуку файлів в Node.js
-------------------------------
коли є такий запис:

  let someData = require('./file');

1. Node.js спочатку шукає файл file
2. потім шукає файл file.js/file.node/file.json
3. потім шукає теку file і хоче там знайти файл index.js, вважає його модулем
4. node_modules різних рівнів вкладеності, починаючи з найглибшого
5. NODE_PATH
   Для windows: set NODE_PATH=.
   Якщо ввести цю команду, надалі модулі-директорії можна підключати без шляхів,
   тільки по імені (назві теки, де є index.js/index.node)


Об'єкт module
=============
Є змінною, яка присутня в кожному файлі-модулі

У цієї змінної є важлива властивість module.parent, яка вказує на модуль, який
запустив виконання даного модуля.

  function run() {…}

  if (module.parent) { // якщо модуль запущений іншим модулем - передати функціонал
    exports.run = run; // там його треба буде запускати як someVariable.run()
  } else {
    run();             // якщо модуль запускається самостійно - виконати
  }

module.exports
--------------
module.exports = exports = this
module.exports - це реальний об'єкт, який потрапляє назовні з модуля
exports - змінна, посилання на об'єкт module.exports
this - в контексті модуля = exports, тобто лише посилання на реальний об'єкт

тому при експорті можна писати:

  module.exports.key = value
  exports.key = value        // це найоптимальніший варіант
  this.key = value

Якщо потрібно експортувати щось одне, напр. функцію, то для того, щоб в
require() потрапляв не проміжний об'єкт з властивістю-функцією, а одразу
напряму функція, потрібно перезатерти об'єкт exports:

  function User(){…}
  module.exports = User
  exports = User       // так не спрацює, бо exports є лише змінною-посиланням
                       // на об'єкт, якщо її змінити, то буквально зміниться
                       // адреса, на яку буде вказувати змінна, сам же об'єкт
                       // залишиться незмінним

модуль-фабрика
--------------

log = require('logger')(module);

суть полягає в тому, що викликається модуль і йому одразу передаються параметри.


NPM
===

Структура пакета:

name (dir)
|-- index.js
|-- package.json

при установці модуля він встає в директорію node_modules, найближчу по ієрархії
вгору, якщо такої директорії нема, Node.js шукає файл package.json, і тільки
якщо ні того, ні другого нема, пакунок встановлюється в поточну директорію

npm init - створення файлу package.json
npm addu[ser] - реєстрація користувача, потрібна для публікації пакунків
npm pu[blish] - вивантаження пакунку, а-ля "git push"
npm s[earch] key_words - пошук пакунка
npm i[nstall] module_name - встановлення пакунка
ipm i express@3.0.2 - поставити конкретну версію пакунка
npm up[date] - перевірка наявних модулів і за необхідності їх оновлення
npm r[emove] module_name - видалення пакета

http://registry.npmjs.org/ - репозиторій усіх модулів
http://registry.npmjs.org/module_name - інфо на конкретний модуль

У файлі package.json є секція scripts, вона використовується для короткого
запису команд консолі, напр.

{
  "name": "modulesapp",
  "version": "1.0.0",
  "scripts" : {
    "start" : "node app.js",
    "dev" : "node app.js Tom 26"
  }
}

В консолі замість node app.js        можна набирати npm start.
    -- // --      node app.js Tom 26    -- // --    npm run dev

Є кілька зарезервованих команд (start, end, …), вони вткликаються напряму, решта -
через проміжну команду run.


Модуль util
-----------

  let util = require('util');

  console.log( util.inspect(obj) ); // красиве виведення об'єкту

  let str = util.format('My %s %d %j', 'qwerty', 123, {test1:'test'}); // формування рядка

  util.inherits(childClass, parentClass) // наслідування


Модуль console
--------------
Є глобальною змінною, що є рідкістю в Node.js
Для виведення інформації використовує util.inspect та util.format.

console.log() == console.info()   // виведення стандартного потоку
console.error() == console.warn() // виведення потоку помилок


Об'єкт EventEmitter
===================

Реалізує роботу з подіями в Node.js

  let EE = require('events').EventEmitter;
  let server = new EE();
  server.on('request', function(arg){…})  // підписка на подію (навішування обробника)
  server.emit('request', {from:"Клієнт"}) // генерація події

Якщо обробників кілька, вони викликаються в порядку оголошення. Вони один одного
не перезатирають.

  emitter.lesteners(events) // повертає усі обробники на дану подію
  EventEmitter.listenerCount(emitter,event) // кількість обробників

server.emit('error'); // покладе скрипт, якщо не призначити обробник!
                      // -> throw TypeError
server.emit('error', new Error()); // -> throw err, яка піде в обробник

server.setMaxListeners(0) // за замовчуванням у EventEmitter є можливість
                          // встановити тільки 10 обробників. Ця команда їх
                          // відключає. Тут треба бути обережним, щоб не було
                          // втрат пам'яті.


Наслідування від EventEmitter
-----------------------------

Для того, щоб у об'єктів була можливість оперувати подіями, їх треба прив'язати
до EventEmitter:

  const util = require("util");
  const EventEmitter = require("events");
  function User(){
  }
  util.inherits(User, EventEmitter);
  let eventName = "greet";
  User.prototype.sayHi = function(data){
    this.emit(eventName, data);
  }
  let user = new User();
  // добавляем к объекту user обработку события "greet"
  user.on(eventName, function(data){
    console.log(data);
  });
  user.sayHi("Мне нужна твоя одежда...");

Те саме на ES6:

  const EventEmitter = require("events");
  let eventName = "greet";
  class User extends EventEmitter {
    sayHi(data) {
      this.emit(eventName, data);
    }
  }
  let user = new User();
  // добавляем к объекту user обработку события "greet"
  user.on(eventName, function(data){
    console.log(data);
  });
  user.sayHi("Мне нужна твоя одежда…");


Створення web-сервера на Node.js
================================

  let http   = require('http'),    // підключення модуля
      server = new http.Server();  // взяти об'єкт з модуля (він є EventEmitter)
                                   // він слухає ip+port і відповідає на запити
  server.listen(1337,'127.0.0.1'); // призначити ip та port для прослуховування

  let counter = 0;
  server.on('request', function(req,res){  // події - для відповідей на запити
    res.end("Привіт, Світ! " + ++counter); // req - об'єкт запиту
  });                                      // res - об'єкт відповіді
k
// res.end() - передати дані, закрити з'єднання;
// res.write() - передати дані і не закривати з'єднання (для наступних передач)

new http.Server() є об'єктом EventEmitter, який наслідує net.Server, який в свою
чергу наслідує http.Server

Модулі в Node.js зроблені таким чином, що перший раз вони читаються, для них
створюються відповідні об'єкти module, а при повторних викликах модуль не
використовується, а іде звернення в кеш до об'єкта. Тому, щоб зміни в коді стали
видні в браузері, сервер потрібно перезапустити.


Sublime + cmd (локальна машина):
--------------------------------
1. Запустити в cmd команду node file_name.js
2. При змінах коду Ctrl+C - зупинка сервера, потім знову node file_name.js
3. Оновити браузер

WebStorm (локальна машина):
---------------------------
1. Потрібно зробити конфігурацію сервера: зверху справа натиснути "Edit
Configurations…", у боковому меню попапа вибрати елемент під Node.js. В полі
"Node interpreter" повинен бути вказаний шлях до node.exe, в "Working
directory" - шлях до робочої директорії проекту, а в "JavaScript.file" - ім'я
файлу з написаним сервером. Поставити пташку на "Single instance only" - це для
того, щоб WebStorm не пробував запускати сервер щоразу новий (все одно буде
помилка EADDRINUSE: address already in use), а зупиняв старий і лише потім
запускав новий.
2. Запустити локальний сервер (кнопка play)


Створення echo-web-сервера на Node.js
=====================================
// http://127.0.0.1:1337/echo?message=Hello -> Hello
let http   = require('http'),
    url    = require('url');                // для парсингу url

let server = new http.Server(function(req,res){

  let urlParsed = url.parse(req.url, true); // true - щоб query: 'message=Hello'
                                            // => { message: 'Hello' }

  // зчитування заголовків запиту
  console.log(req.headers);

  // встановлення заголовку-відповіді для коректного відображення кирилиці
  res.setHeader('Content-type', 'text/html; charset=utf-8');

  // заборона браузеру кешувати відповіді сервера
  res.setHeader('Cashe-Control', 'no-cashe'); // або:
  res.setHeader('Cashe-Control', 'no-cashe no-store must-revalidate');

  // removeHeader('Cashe-Control') - витерти заголовок

  if ( urlParsed.pathname == '/echo' && urlParsed.query.message ) {
    res.end(urlParsed.query.message);
  } else {
    res.statusCode = 404;
    res.end('Page not found');
  }
});

server.listen(1337,'127.0.0.1');


Варіанти запису заголовків:
---------------------------

1. res.setHeader('Content-type', 'text/html; charset=utf-8');
   res.statusCode = 404;

   У цьому випадку заголовки одразу не відправляються, а чекають на передачу
   яких-небудь даних, напр. при res.end()

2. res.writeHead(200, "OK", {'Cashe-Control', 'no-cashe'});
   Явний запис. Заголовки пишуться у відповідь одразу, не чекаючи на найближчий
   запис даних.


supervisor
==========

npm i -g supervisor // встановиться в C:\Users\userName\AppData\Roaming\npm

Слідкує за файлами і у випадку зміни робить перезапуск сервера (watching).
Тепер не потрібно постійно перезапускати сервер, але браузер все-одно
перезапускати потрібно.
У старих версіях має особливість: слідкує тільки за файлами, які існували
на момент запуску. Якщо створбється новий модуль, який буде підключатися через
уже існуючий - теж жодних проблем. Але якщо файл незалежний від інших,
supervisor його не побачить і його доведеться перезапускати.
Також може статися таке: якщо у директорії проекту є node_modules, а там багато
файлів, supervisor також починає за ними слідкувати, що може призвести до
підтуплювання системи. Вирішення проблеми: запуск з параметром ignore, або
перемістити node_modules на рівень вище.


Запуск cmd + Sublime:
---------------------
supervisor file.js // замість node file.js

WebStorm:
---------
потрібно змінити конфігурацію, в поле "Node interpreter" треба внести шлях до
файлу supervisor.cmd


nodemon
=======

Аналог supervisor'a

Відладка коду
=============

debug / inspect
---------------

debug застарів, треба використовувати inspect. Використовуєься рідко, в
основному, коли "продвинуті методи відладки не працюють"

в коді прописати команду debugger,
в консолі:
  node inspect file_name.js

help   - підказки по командах
c[ont] - продовжити виконання
repl   - режим "repl" - можна вводити назви змінних та отримувати їх поточні
         значення, запускати методи і т.д.

Браузер + node-inspector
------------------------

npm i -g node-inspector // Я НЕ ЗМІГ ВСТАНОВИТИ NODE-INSPECTOR, ПОСТІЙНО ВИЛІТАЮТЬ ПОМИЛКИ!!!

В консолі:
  node --debug file_name.js   // метод застарів
  node --inspect file_name.js // використовувати це

В другій консолі:
  node-inspector
У відповідь прийде адреса, яку потрібно ввести в браузер і там буде відбуватися
відлагодження.


Логування
=========

1. Модуль debug
---------------

"рекордсмен по простоті", вивід тільки в консоль

1. Встановити debug
2. Підключити у файлі-модулі і передати мітку (довільний ідентифікатор, який
   потрібно буде вказувати в консолі):

  let debug = require('debug')('id');

3. В модулях, які підтягуються головним модулем, мітка повинна виглядати як
   батьківська мітка:мітка залежного модуля, напр.:

  let debug = require('debug')('id:child_id');

4. У всіх місцях коду, де потрібен вивід якихось даних:

  console.log() -> debug()

5. В консолі прописати змінну оточення DEBUG,
   для windows:

  set DEBUG=id              // debug() з головного файла з міткою id
  set DEBUG=id:child_id     // debug() з файла з міткою id:child_id
  set DEBUG=id, id:child_id // debug() з головного файла та файла з міткою id:child_id
  set DEBUG=id:*            // debug() з усіх залежностей

6. node file_name.js / supervisor file_name.js

2. Модуль winston
-----------------

може робити вивід у файл, базу даних і консоль.
документація по winston:https://www.npmjs.com/package/winston

Має 7 різних рівнів повідомлень за важливістю. За замовчуванням виводить тільки
перші 3: winston.error(), winston.warn(), winston.info();

Для простого виводу в консоль:
------------------------------
1. Встановити і підключити модуль
2. В потрібних місцях коду (вибирати самостійно, на свій розсуд):

  console.log() -> winston.error()
    -- // --    -> winston.warn()
    -- // --    -> winston.info()

Для виводу в log-файл:
----------------------
  const winston = require('winston');
  сonst logger = winston.createLogger({
    level: 'info',
    format: winston.format.json(),
    defaultMeta: { service: 'user-service' },
    transports: [
      // Write all logs with level `error` and below to `error.log`
      new winston.transports.File({ filename: 'error.log', level: 'error' }),
      // Write all logs with level `info` and below to `combined.log`
      new winston.transports.File({ filename: 'combined.log' }),
    ]
  });
  logger.info(…);

Приклад з обгорткою для winston (echo-server):
----------------------------------------------

// server.js

  let http = require('http'),
      log  = require('./log')(module);

  let server = http.createServer();
  server.on('request', require('./request'));
  server.listen(1337);

  log.debug("Server is running");

// request.js:

  let url = require('url'),
      log = require('./log')(module);

  module.exports = function(req,res){
    let urlParsed = url.parse(req.url, true);

    log.info('Got request, method: ' + req.method + ', url: ' + req.url);

    if (req.method == 'GET'
        && urlParsed.pathname == '/echo'
        && urlParsed.query.message) {

      let message = urlParsed.query.message;
      log.debug('Echo: ' + message);
      res.end(message);
      return;
    }

    log.error('Unknown URL');

    res.statusCode = 404;
    res.end('Not Found');
  };

// log.js:

  let winston = require('winston');

  module.exports = function(module) {
    return makeLogger(module.filename);
  }

  function makeLogger(path) {
    if ( path.match(/request.js$/) ) {

      let transports = [
        new winston.transports.Console({
          timestamp : true,
          colorize  : true,
          level     : 'info'
        }),
        new winston.transports.File({
          filename  :'debug.log',
          level     : 'debug'
        })
      ];

      const {format} = require('winston');
      const { combine, timestamp, label, printf } = format;
      const myFormat = printf(({ level, message, label, timestamp }) => {
        return `${timestamp} [${label}] ${level}: ${message}`;
      });

      return new winston.createLogger({
        format: combine(
            label({ label: 'some text' }),
            timestamp(),
            myFormat
          ),
        transports: transports
      });
    } else {
      return new winston.createLogger({
        transports: []
      });
    }
  }

3. Глибоке відлагодження
------------------------
(У МЕНЕ ЗНОВУ-ТАКИ НЕ ПРАЦЮЄ)

NODE_DEBUG="cluster fs http module net timer tls"

Наприклад, для перевірки, що передається по мережі:

  NODE_DEBUG="http net" node file_name.js


Асинхронна розробка
===================

1. Не блокує інтерпретатор
2. Не працює try … catch ( помилки в callback(err) )
3. Помилки потрібно обробляти обов'язково, інакше скрипт почне глючити (він не
   ляже, як при синхронній розробці).
4. В асинхронних методах є функція-колбек. Існує угода, що перший її аргумент -
   об'єкт помилки, другий - результат. Якщо метод завершиться з помилкою, буде
   визваний callback(err), якщо успішно - callback(null, result).


Бібліотека LibUV
================

Написана на С і вбудована в Node.js.
Відповідає:
1. Кросплатформенна робота з файлами, операціями введення-виведення, мережею.
2. Підтримка основного цикла подій:
   ( .. -> JS -> таймери, введення-виведення -> JS -> .. ).


Поки JS зайнятий обробкою коду, усі події встають у чергу LibUV, і чекають, поки
інтерпретатор JS не звільниться. Щоб не було тривалих зависань через важкі
задачі в JS, можна:
1. Виділити важкі задачі в окремі процеси
2. Виділити важкі задачі в окремі потоки
3. Запустити сервер Node.js в режимі великої кількості процесів (напр. cluster)
4. Розбити важкі задачі на частини із setTimeout, тоді між цими таймерами будуть
   оброблятися і обробники в LibUV



***
server.close() // сервер припиняє слухати порт (нові запити не приймаються), але
               // поки є ще якісь старі обробники, сервер продовжує їх
               // обслуговувати. Як тільки усі обробники виконані, сервер
               // закривається повністю.

process.memoryUsage() // виводить в консоль використання пам'яті

process.exit() // повна зупинка основного циклу подій


Таймери
=======

let timer = setIntervsl(…);
timer.unref() // вказує бібліотеці libUV, що таймер другорядний і його не треба
              // враховувати при перевірці можливості завершення процесу.
timer.ref()   // зворотна до timer.unref() дія

process.nextTick(function(){…}) // якісна заміна setTimeout(function(){},0):
                                  // код виконається асинхронно, після виконання
                                  // поточного коду, але гарантовано перед
                                  // можливими наступними подіями
                                  // введення-виведення або таймерами, причому,
                                  // якщо є вкладені рекурсивні виклики
                                  // nextTick, вони виконуватимуться одразу, теж
                                  // перед подіями і таймерами. Тобто nextTick є
                                  // асинхронним, але пригальмовує цикл подій

setImmediate(function(){…}) // асинхронне виконання, після виконання поточного
                              // JS-коду та усіх уже запланованих на виконання
                              // асинхронних задач. Якщо є вкладені виклики,
                              // вони, на відміну від process.nextTick, не
                              // блокують цикл подій, а виконуються на наступних
                              // ітераціях цього циклу


***
Коди помилок (напр ENOENT) визначаються бібліотекою LibUV
https://github.com/nodejs/node-v0.x-archive/blob/3d3d48d4b78d48e9b002660fc045ba8bb4a96af2/deps/uv/include/uv.h#L65
http://docs.libuv.org/en/v1.x/errors.html


Файлова система
===============

__filename // звернення до файлу виконуваного модуля
__dirname  // абсолютний шлях до директорії

fs.readFile(__filename, 'utf-8', fonction(err,result){}); // зчитати файл,
                                                          // без 'utf-8' - Buffer
fs.writeFile('name.txt', 'data', fonction(err,result){}); // створити файл
fs.rename('n1.txt', 'n2.txt', fonction(err,result){});    // перуйменувати
fs.unlink('name.txt', fonction(err,result){});            // видалити

fs.stat(filePath,function(err,stats)){ // перевірка, чи існує вказаний шлях
  console.log( stats.isFile() )        // директорія чи файл?
}

Read Files
----------

  fs.readFile()

Create Files
------------

  fs.appendFile() // method appends specified content to a file. If the file
                  // does not exist, the file will be created

  fs.open()       // method takes a "flag" as the second argument, if the flag
                  // is "w" for "writing", the specified file is opened for
                  // writing. If the file does not exist, an empty file is
                  // created
    fs.open('mynewfile2.txt', 'w', function (err, file) {...});

  fs.writeFile()  // method replaces the specified file and content if it
                  // exists. If the file does not exist, a new file, containing
                  // the specified content, will be created

Update Files
------------

  fs.appendFile() // method appends the specified content at the end of the
                  // specified file

  fs.writeFile()  // method replaces the specified file and content

Delete Files
------------

  fs.unlink()

Rename Files
------------

  fs.rename()


Потоки
======

потоік - js-об'єкт, який отримує інформацію про діні і вміє з цими даними
працювати.

вбудовані класи stream.Readable ті stream.Writable, самі використовується рідко,
в основному їх нащадки:
  fs.ReadStream / fs.WriteStream
  server.on('request', …req… ) / server.on('request', …res… )
  res instanceof http.Server.Responce instenceof stream.Writable

також є інші типи потоків


stream.ReadStream
-----------------

Коли відкривається новий потік new stream.ReadStream, створюється об'єкт, який
підключається до даних і після прочитання порції даних генерує подію "readable"
(прочитані дані доступні через метод read()), і переходить в режим очікування,
з якого виходить викликом методу read(). Коли дані закінчуються, виникає
подія "end".
Для обриву потоку є метод destroy().
При відкритті потоку, файл зчитується не повністю, а порціями по 65536 байт
(64 Кб).
Для потоку fs.ReadStream є дві додаткові події - "open" та "close". Коли файл
дочитаний, "end" -> "close", якщо файл не дочитаний (помилка, destroy()), події
"end" не буде.


Відмінність між fs.readFile та fs.ReadStream:
---------------------------------------------

fs.readFile спочатку прочитає ВЕСЬ файл, потім викличе callback, а fs.ReadStream
читає файл потоком, тобто частинками по 64 кб, в результаті чого fs.readFile
може з'їсти усю пам'ять і затупити сервер, а fs.ReadStream утворює окремий потік
і не напружує сервер. Хоча і перше, і друге є асинхронним кодом.


stream.Writeable
----------------

Спочатку створюється об'єкт потоку. Для передачі даних використовується метод
write(data), причому дані додаються до спеціальної властивості потоку - буфера.
Якщо буфер не великий, дані циклом дозаписуються в нього ( кожний виклик
write(data) повертає true). Відсилку даних потік виконує самостійно. Якщо ж
буфер був заповнений, або було передано одразу багато даних, метод write(data)
поверне false. У цьому випадку треба зачекати з передачею даних і дочекатися
події "drain" (потік її генерує, коли всі дані з буфера були відіслані).
Коли усі дані передані і write(data) повернув true, потрібно викликати метод
end([data]), якщо його визвати з аргументом, він викличе мето write(data).
По завершенні усіх операцій згенерується подія "finish", аналог "end" у
stream.ReadStream (вони названі навмисно по різному, бо є потоки-дуплекси, які
здатні читати і писати і їм важлива різниця в методах).
Для обриву потоку є метод destroy(). Якщо його викликати, подія "finish" не
відбудеться.

У fs.Writeable також є подія 'close', вона сигналізує про обрив передачі даних
(у fs.ReadStream подія з аналогічною назвою сигналізує про кінець зчитування
файлу).
Якщо на стороні клієнта відбудеться обрив зв'язку, на стороні сервера подія
"close" fs.readFile-потоку не спрацює (адже сервер нормально все зчитує).
Виходить так, що передача файлу завершитися не може і зависає: займається
пам'ять буфера, не помирають усі залежності із замикань. Якщо клієнт кілька
разів повторить дії, які призведуть до повторення такої ситуації, сервер сильно
напружиться. Щоб цього уникнути, потрібно відловлювати подію "close" на пишучому
потоці fs.Writeable і робити обрив читаючого потоку fs.ReadStream його методом
destroy().



Метод pipe():
-------------

зчитує дані з потоку stream.ReadStream і записує в потік (потоки)
stream.Writeable

Readable.pipe(Writable1);
Readable.pipe(Writable2);


Модуль domain
=============
Допомагає відловлювати програмні помилки в асинхронному коді. В контексті domain
можна запускати функції і він ловитиме усі помилки, включно з вкладеними
функціями.

  let domain = require('domain'),
      server = require('./server');

  let serverDomain = domain.create();

  serverDomain.on('error', function(err){
    console.error('Домен перехопив %s ', err);
  });

  serverDomain.run(function(){
    server.listen(3000);
  });


Читання параметрів з командного рядка і оточення
================================================

1. варіант:

  console.log(process.argv); // argv[0] - шлях до node.exe
                             // argv[1] - шлях до виконуваного скрипта
                             // argv[2], …, argv[n] - передані аргументи

  запуск: node server.js port=3000

2. варіант - модуль optimist + node:

  let argv = require('optimist').argv;

  cmd: node server.js --port=3000 або
       node server.js port 3000

  Webstorm: у полі "Application parameters" поставити --port=3000

3. варіант - модуль optimist + supervisor:

  cmd: supervisor -- server.js --port=3000

  Webstorm: у полі "Path to Node" вказати шлях до supervisor.cmd,
            у полі "Node Parameters" прописати --

4. варіант - змінні оточення. Ці змінні доступні в коді в process.env:

   cmd: set DEBUG=some_name

   Webstorm: у полі "Environment variables" додати змінну NODE_ENV
   (для express вона рівна або production, або development)


Шаблони
=======

html:
<!DOCTYPE html>
<html>
<head>
  <title>Главная</title>
  <meta charset="utf-8" />
</head>
<body>
  <h1>{header}</h1>
  <p>{message}</p>
</body>
<html>

js:
const http = require("http");
const fs = require("fs");
http.createServer(function(request, response){
  fs.readFile("index.html", "utf8", function(error, data){
    let message = "Изучаем Node.js";
    let header = "Главная страница";
    data = data.replace("{header}", header).replace("{message}", message);
    response.end(data);
  })
}).listen(3000);