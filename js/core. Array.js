// створення масивів:
  let arr = [];                                   // синтаксис «літерал об’єкту»
  let arr = new Array("Яблуко", "Груша", "тощо"); // синтаксис «конструктор об’єкту»

// • Якщо array = new Array(2); має тільки один цифровий аргумент, то замість
//   створення масиву з одним елементом, він створить масив без елементів з
//   довжиною, вказаною в аргументі.

let array = ['one', 'two', 'three']; // нумерація елементів починається з нуля
let array = ['one', 2, 3, true];     // масиви можуть мати змішані типи даних
console.log(array);                  // виведення значення всього масиву
console.log(array[0]);               // виведення значення 1-го елементу масиву
array[0] = 'trololo';                // переприсвоєння значення елементу масиву
delete arr[1];                       // значення елементу з індексом 1 видалено,
                                     // утворюється дірка (undefined)
array.indexOf(value);                // виведення індексу елементу

// • довжина length – не кількість елементів масиву, а останній індекс + 1

console.log(array.length);  // визначення довжини масиву
array.push('four', 'five'); // додавання елементу (ів) у кінець масиву
array.pop();                // видалення елементу з кінця масиву
array.unshift('zero');      // додавання елементу (ів) на початок масиву
array.shift();              // видалення елементу з початку масиву


// в один і той же масив можна вносити різні властивості:
  array[99999] = 5;
  array.age = 25;


// в масив можна вкладати інший масив:
  array[1] = [1,2,3,4,[12,13], … , n];


// властивості можна задавати не по порядку:
  let a = [];
  a[0] = 0;
  a[5] = 5;
  console.log( a ); // 0,,,,,5


// скорочення довжини масиву:
  let arr = [1, 2, 3, 4, 5];
  arr.length = 2;            // обрізати до 2 елементів
  console.log( arr );        // [1, 2]
  arr.length = 0;            // очистити масив


// Метод split() – (рядок -> масив) – розділення рядку на масив із
// розділювальним символом. Другий аргумент (не обов’язковий) вказує, після
// якого символу припинити сепарацію:
  console.log( "a,b,c,d".split(',', 2) ); // a,b


// розбиття рядка на окремі букви – split з пустим рядком:
  let str = "тест";
  console.log( str.split('') ); // т,е,с,т


// Метод join() – (масив -> рядок) – склеювання масиву у рядок. (';') –
// вказується символ, яким буде розділено елементи. Якщо () – як розділовий знак
// використовується кома, якщо ('') – склеювання без знаків і пробілів:
  let arr = ['Маша', 'Петя', 'Марина', 'Василий'];
  let str = arr.join(';');
  console.log( str ); // Маша;Петя;Марина;Василий


// new Array + join = повторення рядку:
console.log( new Array(4).join("ля") ); // ляляля, new Array(4) робить масив без
                                        // елементів довжини 4, який join
                                        // об’єднує в рядок, вставляючи між його
                                        // елементами рядок ля


// Метод splice – видалення, заміна, вставка елементів:
array.splice(x,y);                        // видалення з позиції x y елементів
array.splice(x,y, "elem-1", …, "elem-n"); // видалення з позиції x y елементів,
                                          // замість них в тіло масиву вставити
                                          // елементи "elem-1", …,  "elem-n".
                                          // Якщо y=0, видалення не буде, буде
                                          // тільки вставка. Параметр х може
                                          // бути мінусовим, тоді він відраховує
                                          // від кінця масиву


// Метод slice(begin, end) – копіювання частини масиву від begin включно до end
// не включно, якщо не вказати end – то до кінця. Параметр begin може бути
// мінусовим, тоді він відраховує від кінця масиву. Якщо slice() без аргументів,
// скопіюється увесь масив:
  let arr = ("Яблуко", "Груша", "Слива", "Абрикос");
  let arr2 = arr.slice(1, 3);
  console.log( arr2 ); // Груша, Слива


// розташувати масив у зворотному порядку
  array.reverse();


// Метод arr.indexOf(searchElement[, fromIndex]) повертає номер елемента
// searchElement в масиві arr або -1, якщо його нема. Пошук починається з номеру
// fromIndex, якщо він вказаний. Якщо ні – з початку масиву. Для пошуку
// використовується строге порівняння ===.
  let arr = [1, 0, false];
  console.log( arr.indexOf(0) );     // 1
  console.log( arr.indexOf(false) ); // 2
  console.log( arr.indexOf(null) );  // -1


// Те саме, що і arr.indexOf(searchElement[, fromIndex]), але справа на ліво.
  arr.lastindexOf(searchElement[, fromIndex]);


// перевіряє, чи є  arr масивом, повертає true/false
  arr.isArray();


// Перевірка на наявність в масиві піделементу, повертає true/false; from – не
// обов’язковий аргумент, визначає позицію, з якої шукати. На відміну від
// indexOf/lastindexOf коректно обробляє NaN.
  arr.includes(item [, from]);


// Cтворення масиву з ітерованого об’єкту або псевдомасиву. mapFn – функція, яка
// дозволяє видозмінити елемент перед додаванням його у масив.
  Array.from(obj[, mapFn, thisArg]);


// Метод arr.concat(value1, value2, … valueN) створює новий масив, додаючи до
// старого нові значення, якщо серед значень є вкладені масиви, він додає їх як
// елементи:
  let arr = [1, 2];
  let newArr = arr.concat([3, 4], 5); // те саме, що arr.concat(3,4,5)
  console.log( newArr );              // 1,2,3,4,5

// • Об’єкти додаються як [object Object], але якщо у об’єкта є спец.
//   властивість [Symbol.isConcatSpreadable]: true, то до масиву будуть додані
//   усі значення, ключі яких є цифрами.


// Метод array.sort() змінює масив на місці, змінюючи в ньому порядок елементів.
// Повертає відсортований масив, який можна ігнорувати, бо сам масив array
// видозмінюється.

// Метод sort() – лексикографічне сортування (за замовчуванням):
  let array = [1,2,15];
  array.sort();
  console.log(array); // 1,15,2


// Метод sort() – числове сортування:
  array.sort(function (a, b){
    if (a > b) return 1;
    if (a < b) return -1;
    if (a == b) return 0;
  });


// або більш коротко:
  array.sort(function (a, b){
    return a - b; // для [{},{}, … ,{}]: a.key - b.key
  });


// випадкове сортування масиву:
  let arr = [1, 2, 3, 4, 5];
  function compareRandom(a, b) {
    return Math.random() - 0.5;
  }
  arr.sort(compareRandom);


// перебирання елементів масиву – for() або for … of (не надає доступу до номера
// поточного елементу, тільки до значення) (for … in не використовувати, бо він
// виводить зайві нецифрові властивості і до того ж повільніше працює):
  let arr = ["Яблуко", "Апельсин", "Груша"];
  for (let i = 0; i < arr.length; i++) {
    console.log( arr[i] );
  }


// Зробити копію масиву:
// 1. Array.from(obj);
// 2. arr.concat();
// 3. arr.slice();
// 4. Тупий перебір.


// ПЕРЕБИРАЮЧІ МЕТОДИ МАСИВІВ

// Метод arr.forEach(callback (item, i, arr){}) – перебирання масиву. Метод
// нічого не повертає. Для кожного елементу масиву викликає  функцію callback,
// якій передає три параметри: item – черговий елемент масиву, i – його номер,
// arr – масив, який перебирається:
  let arr = ["Яблуко", "Апельсин", "Груша"];
  arr.forEach(function(item, i, arr) {
    console.log( i + ": " + item + " (масив:" + arr + ")" );
  });


// Метод arr.find(callback (item, i, arr){}) – пошук елементу в масиві. Якщо
// елемент знайдено (перший підхожий) — повертається знайдений елемент і пошук
// припиняється. Якщо ні — вертається undefined;
  let users = [
    {id: 1, name: “Вася”},
    {id: 2, name: “Петя”},
    {id: 3, name: “Маша”}
  ];
  let user = users.find(item => item.id == 1);


// Метод arr.findIndex(callback (item, i, arr){}) – пошук елементу в масиві.
// Аналог arr.find(callback (item, i, arr){}), але повертає індекс знайденого
// елемента або -1;


// Метод arr.filter(callback(){}) – фільтрація масиву через функцію. Створює
// новий масив, в який увійдуть тільки ті елементи arr, для яких виклик
// callback() поверне true.
  let arr = [1, -1, 2, -2, 3];
  let positiveArr = arr.filter(function(number) {
    return number > 0; // [1,2,3]
  });
  console.log( positiveArr );


// Метод arr.map(callback(item,index,array){}) - трансформація масиву. Створює
// новий масив, який буде складатися з результатів виклику callback() для
// кожного елемента arr.
  let names = ['HTML', 'CSS', 'JavaScript'];
  let nameLengths = names.map(function(name) {
    return name.length; // отримали масив з довжинами - 4,3,10
  });
  console.log( nameLengths );


// Метод arr.every(callback(){}) повертає true, якщо виклик callback поверне
// true для кожного елементу arr.
// Метод arr.some(callback(){}) повертає true, якщо виклик callback поверне true
// для якого-небудь елемента arr.
  let arr = [1, -1, 2, -2, 3];
  function isPositive(number) {
    return number > 0;
  }
  console.log( arr.every(isPositive) ); // false, не всі більше нуля
  console.log( arr.some(isPositive) );  // true, є мінімум одне більше нуля


// Метод arr.reduce(callback(previousValue, currentItem, index, arr){}) –
// послідовна обробка кожного елементу масиву зі збереженням проміжного
// результату.
// Аргументи функції callback():
// previousValue – останній результат виклику функції, він же проміжний
// currentItem – поточний елемент масиву
// index – номер поточного елементу
// arr – оброблюваний масив
// Крім callback методу можна передати "початкове значення" – аргумент
// initialValue. Якщо він є, то на першому виклику значення previousValue буде
// рівне initialValue, а якщо у reduce нема другого аргументу, то воно рівне
// першому елементу масиву, а перебирання починається з другого.
  let arr = [1, 2, 3, 4, 5]
  let result = arr.reduce(function(sum, current) {
    return sum + current;
  }, 0);                  // 0 – другий аргумент reduce (початкове sum)
  console.log( result );  // 15

// • Якщо масив пустий, то виклик reduce без initialValue викличе помилку.


// Метод arr.reduceRight(callback(previousValue, currentItem, index, arr){}) –
// повний аналог Метод arr.reduce(…), тільки справа на ліво.