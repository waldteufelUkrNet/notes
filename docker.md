Docker
================================================================================

**Docker** - це технологія створення і управління контейнерами. Контейнери
придумані для того, щоб ізолювати код, розташований в них, і гарантувати
однаковість його виконання на різних машинах з різними операційними системами.
Єдине, що треба, - це наявність самого doker на машині (він має бути запущеним).

**Docker** дозволяє ізолювати застосунки, не створюючи під кожен з них свою
віртуальну машину. За його допомогою можна не запускати напр. сервер nginx
напряму, а запустити docker-контейнер, в якому, як в матриці, буде запущений
свій екземпляр nginx. Ззовні для операційної системи цей екземпляр буде не
видимим, операційна система просто виконуватиме **Docker** як один зі своїх
процесів.

Застосунки, запущені з різних контейнерів навіть на одній машині, спілкуються
між собою по мережі, через мережеві адреси.

Ключовими поняттями **Docker** є **рушій (engine), образ (image), контейнер
(container)** та **том (volume)**. **Рушій** - це запущений екземпляр програми
**Docker**, без нього доступ до образів і контейнерів не можливий. **Образ**
можна порівняти з iso-образом операційної системи, а **контейнер** - відповідно
із встановленим і запущеним екземпляром операційки. **Образи** або
завантажуються з репозиторію https://hub.docker.com/, або створюються
власноручно за допомогою файла **Doсkerfile**, в якому прописуються потрібні
команди. До образів і контейнерів можна звертатися за іменами або
ідентифікаторами.

**Томи** - це спеціальні сховища даних, які знаходяться за межами образів і
контейнерів. Для розуміння їх суті підійде аналогія з диском D комп'ютера: на
ньому просто зберігаються дані, а при переустановці windows затирається диск C
(контейнер), але сам диск D не форматується.

подивитися доступні команди **Docker**:
```shell
docker
```


Робота з образами
--------------------------------------------------------------------------------

переглянути наявні образи:
```shell
docker image ls
docker images
```

завантажити образ з репозиторію (якщо цього не зробити, **Docker** це зробить
сам, коли буде читати **Doсkerfile**):
```shell
docker pull image_name
```

згенерувати образ, вказаний в **Doсkerfile** (. - шлях до файлу):
```shell
docker build .
```

при генерації можна вказати ім'я образу та версію (в таблиці образів вона
записується в колонку TAG):
```shell
docker build -t image_name:image_version .
```

видалити образ:
```shell
docker rmi image_id 
```

клонувати образ:
```shell
docker tag old_name new_name
```

створити образ із контейнера:
```shell
docker commit container_id image_name
```

створений образ можна залити на репозиторій **Docker** (для цього потрібно
зареєструватися нa **Docker**):
```shell
docker push user_name/image_name
```


Робота з контейнерами
--------------------------------------------------------------------------------

подивитися список усіх контейнерів:
```shell
docker ps -a
```

подивитися список запущених контейнерів:
```shell
docker ps
```

вивести ідентифікатори усіх контейнерів:
```shell
docker ps -a -q
```

>**Контейнер відкритий доти, поки працює застосунок. Як твльки застосунок
завершився, контейнер закривається**

> **Запустити контейнер можна двома шляхами: або командою *run image*, або
командою *start container***. Відмінність полягає у тому, що при використанні
команди ***start*** запускається уже наявний контейнер, а команда ***run***
спочатку створює контейнер на основі образа, а потім його запускає. При
повторному використанні команди ***run*** буде створений ще один аналогічний
контейнер (щоб цього уникнути, потрібно використовувати ключ ***--rm***, який
видалить контейнер після закриття).

запустити контейнер напряму:
```shell
docker start container
```

запустити контейнер на основі образа:
```shell
docker run image
```

запустити контейнер в інтерактивному режимі (поки контейнер запущений,
консоль блокується):
```shell
docker run -it image
```

запустити контейнер у фоновому режимі (запущений контейнер не блокує консоль):
```shell
docker run -d image
```

запустити контейнер з доступом до localhost. -p - порт, перші 3000 - порт для
localhost, другі 3000 - порт, прописаний у контейнері
```shell
docker run -d -p 3000:3000 image_id
```

при запуску образів можна давати ім'я контейнеру, прапор --rm говорить про те,
що контейнер буде видалений після зупинки:
```shell
docker run -d -p 3000:3000 --name container_name --rm image
```

??? завершити роботу контейнера:
```shell
exit
```

завершити роботу контейнера:
```shell
docker stop container
```

видалити контейнер:
```shell
docker rm container
```

видалити всі не активні контейнери:
```shell
docker container prune
```
або
```shell
docker rm $(docker ps -qa)
```

приєднатися до запущеного контейнера:
```shell
docker attach container
```


Doсkerfile - інструкція для створення образу
--------------------------------------------------------------------------------

Коренем проекту **Docker** вважається директорія, де лежить файл **Doсkerfile**.
Кожного разу після зміни **Doсkerfile** потрібно перезбирати образ.

Приклад **Doсkerfile** (створення образу з якого потім створиться контейнер):
```
FROM node              # image_name, якщо такого нема, Docker качає його з
                       # репозиторія, якщо його нема в репозиторії, буде помилка
WORKDIR /app           # шлях до файлів у образі
COPY . .               # скопіювати локальні файли в образ з кореня в корінь або
                       # місце, вказане в WORKDIR образа. Можна й інші варіанти,
                       # напр. COPY . /app (якщо нема WORKDIR)
EXPOSE 3000            # вибір порта
RUN npm install        # запустити команду після зібрання образу
CMD ["node", "app.js"] # виконання команд після запуску образу
```

оптимізований приклад (при перекомпіляції образу node-модулі братимуться з кешу):
```
FROM node              
WORKDIR /app
COPY package.json /app
RUN npm install
COPY . .
EXPOSE 3000
CMD ["node", "app.js"]
```

.dockerignore - список файлів, не потрібних в образі
--------------------------------------------------------------------------------

приклад **.dockerignore**:
```
node_modules
.git
Dockerfile
```

Змінні оточення
--------------------------------------------------------------------------------

1. записуються в **Doсkerfile**:
   ```
   ENV PORT 4200
   EXPOSE $PORT
   ```
   ```shell
   docker run -d -p 3000:4200 --rm --name container_name image
   ```

2. прописуються в консолі:
   ```shell
   docker run -d -p 3000:80 --rm -e PORT=80 --name container_name image
   ```

3. прописуються у файлі .env:
   ```
   PORT=3000
   ```
   ```shell
   docker run -d -p 3000:4200 --rm --name container_name --env-file ./config/.env image
   ```

Makefile
--------------------------------------------------------------------------------

**Makefile** - файл з інструкціями, щось аналогічне до секції **scripts** файла
**package.json**. Записується в корінь проекту.

Приклад **Makefile**:

```
run:
  docker run -d -p 3000:4200 --rm --name container_name --env-file ./config/.env image
stop:
  docker stop container
```

запуск команд в консолі (для цього повинен бути встановлений make):
```shell
make run
make stop
```


Томи
--------------------------------------------------------------------------------

**Томи** - це теки на локальній машині (не знаходяться ні в образах, ні в
контейнерах), можуть монтуватися в контейнери. Призначені для збереження даних,
навіть якщо контейнер був видалений. Бувають анонімні та іменовані. Шляхи до
томів прописуються в **Doсkerfile**:

```
VOLUME ["/app/path/to/volume"]
```

Для використання тому його потрібно прописати в команді у форматі абсолютний
шлях до теки зовні (зі сторони розробника):шлях до теки відносно контейнера,
напр. ```B:\files\work_area\Malevich\HYPT\api:/usr/src/app```. Також можна явно
створити том і його примонтувати:
```shell
docker volume create volume_name
docker run -d -p 3000:4200 -v volume_name:/path/to/volume --rm --name container_name image
```


### Використання томів для livereload під час розробки

**Makefile**:
```
run-dev:
  docker run -d -p 3000:4200 -v "/absolute/path/to/volume:/app" -v /app/node_modules -v volume_name:/app/path/to/volume --rm --name container_name image
```
В коді вище додані том для node-модулів та анонімний том. Після запуску команди
при зміні коду в браузері потрібно натискати ctrl+f5.


Деплой
--------------------------------------------------------------------------------

1. залити образ в docker hub:
   ```shell
   docker tag local_image docker_hub_user_name/image_name
   docker push docker_hub_user_name/image_name
   ```
2. на vps:
   ```shell
   docker pull docker_hub_user_name/image_name
   docker run -d -p 80:3000 --name container_name --rm docker_hub_user_name/image_name
   ```
3. в браузері перейти на ip vps


Docker Compose
--------------------------------------------------------------------------------

**Docker Compose** є надбудовою над **Docker**, яка дозволяє автоматизовано
запускати застосунок, який розбитий на кілька контейнерів, без потреби запускати
кожен контейнер вручну.

Для його використання в корені проекту потрібно створити файл
**docker-compose.yml** з інструкціями для запуску.



Посилання
--------------------------------------------------------------------------------

1. [Офіційний сайт](https://www.docker.com/)
2. [Youtube: Зачем нужен и как работает Docker — ликбез](https://www.youtube.com/watch?v=KS80Knz-1Z4)
3. [Youtube: Основы Docker. Большой практический выпуск](https://www.youtube.com/watch?v=QF4ZF857m44)
4. [Youtube: Docker для Начинающих - Полный Курс [2021]](https://www.youtube.com/watch?v=n9uCgUzfeRQ&t=133s)
5. [Youtube: Docker - Всё что нужно знать чтобы начать работать с Docker, все основы в одном уроке](https://www.youtube.com/watch?v=I18TNwZ2Nqg)
6. [Youtube: Docker уроки для начинающих от А до Я - что такое docker ?](https://www.youtube.com/watch?v=EbEZgdTOHzE&list=PLD5U-C5KK50XMCBkY0U-NLzglcRHzOwAg)