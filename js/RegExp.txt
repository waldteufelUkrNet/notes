RegExp
================================================================================

ЩО ЦЕ ТАКЕ
----------

Регулярні вирази - потужний засіб пошуку і заміни в рядку. Регулярні вирази є
об'єктами вбудованого класу RegExp.


ДОКУМЕНТАЦІЯ ПО RegExp
----------------------

https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/RegExp
https://regexr.com


ОГОЛОШЕННЯ
----------

Регулярний вираз складається з шаблона (патерна) та не обов'язкових прапорів.

1. let regexp = new RegExp("шаблон", "прапори");

2. let regexp = /шаблон/прапори;

Різниця в типах оголошення: 2й тип (слеші) не дозволяє використовувати змінні,
він повністю статичний. 1й тип дозволяє використовувати інтерполяцію:

    let tag    = prompt("Який тег потрібно знайти?", "h2"),
        regexp = new RegExp(`<${tag}>`);


ПРАПОРИ
-------

i : пошук не залежить від регістру (А = а);
g : пошук шукає усі співпадіння, без нього - тільки перше;
m : багаторядковий режим, впливає тільки на поведінку якорів ^ та $;
s : режим "dotall": крапка є будь-яким символом + символом переводу рядка (\n);
u : повна підтримка юнікоду (сурогатні пари тощо);
y : режим пошуку на конкретній позиції в тексті;


ПОШУК str.match(regexp)
-----------------------

    let str = 'Abc abb abc';

    let result1 = str.match(/abc/gi); // [ "Abc", "abc" ]
    let result2 = str.match(/abc/i);  // [ "Abc" ] *
    let result3 = str.match(/bcd/gi); // null **
    __________
    *  - коли нема прапора g, match поверне один елемент у вигляді масиву, цей
         масив матиме додаткові властивості: result2.index (позиція співпадіння)
         result2.input (вихідний рядок)
    ** - коли співпадінь нема, повертається null, якщо потрібен масив:
         let result2 = str.match(/abc/i) || [];


ЗАМІНА str.replace(regexp, replacement)
---------------------------------------

    let str = 'We will, we will';

    // без g
    "We will, we will".replace(/we/i, "I"); // I will, we will

    // з g
    "We will, we will".replace(/we/ig, "I"); // I will, I will


В рядку replacement можна використовувати комбінації:

$&      вставляє усе знайдене співпадіння
$`      вставляє частину рядка до співпадіння
$'      вставляє частину рядка після співпадіння
$n      якщо n 1-2 значне число, вставляє вміст n-ї дужкової групи регулярки
$<name> вставляє вміст дужкової групи з іменем name
$$      вставляє символ "$"

    "Люблю HTML".replace(/HTML/, "$& і JavaScript"); // Люблю HTML і JavaScript


ПЕРЕВІРКА regexp.test(str)
--------------------------

    let str = "Я ЛюБлЮ JavaScript";
    let regexp = /люблю/i;

    regexp.test(str); // true


СИМВОЛЬНІ КЛАСИ
---------------

Символьні класи - це спеціальне позначення, яке відповідає будь-якому символу з
певного набору.

\d : цифри
\D : не цифри
\s : пробільні символи, таби, нові рядки (\t, \n, \v, \f, \r)
\S : все, крім \s
\w : латиниця, цифри, підкреслення '_'
\W : все, крім \w
.  : будь-який символ, якщо з прапором регулярного виразу s, інакше будь-який
     символ, крім переводу рядка \n


Приклади:
---------

перша цифра в номері телефона:

    let str = "+7(903)-123-45-67";
    console.log( str.match(/\d/) ); // 7

усі цифри з номера телефона:

    let str = "+7(903)-123-45-67";
    console.log( str.match(/\d/g) ); // 7,9,0,3,1,2,3,4,5,6,7
    console.log( str.match(/\d/g).join('') ); // 79035419441

усі цифри з номера телефона (видалити не цифри):

    let str = "+7(903)-123-45-67";
    console.log( str.replace(/\D/g, "") ); // 79031234567

регулярні вирази можуть мати як символи, так і символьні класи, в тому числі
кілька класів:

    \d\s\w - цифра, за якою іде пробіл і символ, напр. '1 a'
    CSS\d  - рядок 'CSS' + цифра

    console.log( "I love HTML5!".match(/\s\w\w\w\w\d/) ); // ' HTML5'

крапка - будь-який символ, крім \n:

    let regexp = /CS.4/;
    console.log( "CSS4".match(regexp) ); // CSS4
    console.log( "CS-4".match(regexp) ); // CS-4
    console.log( "CS 4".match(regexp) ); // CS 4
    console.log( "CS4".match(regexp) );  // null
    console.log( "A\nB".match(/A.B/) );  // null

крапка - будь-який символ, якщо з прапором s:

    console.log( "A\nB".match(/A.B/s) ); // A\nB


ПІДТРИМКА UNICODE. КОНСТРУКЦІЯ \p{…}
------------------------------------

Для роботи з юнікодом потрібер прапор u!

У кожного символа в юнікоді є багато властивостей, що містять додаткову
інформацію про символ. В регулярних виразах можна шукати символ за цими
властивостями, використовуючи конструкцію \p{…}

    \p{Letter} (або \p{L}) // буква будь-якої мови


    let str = "A ბ ㄱ";
    console.log( str.match(/\p{L}/gu) ); // A,ბ,ㄱ
    console.log( str.match(/\p{L}/g) ); // null


Категорії символів (основні):
-----------------------------

  Букви L:
      Ll нижній регістр
      Lm модифікатори
      Lt заголовні букви
      Lu верхній регістр
      Lo інше

  Числа N:
      Nd десяткові цифри,
      Nl цифри, позначені буквами (римські)
      No інше

  Знаки пунктуації P:
      Pc з'єднувальні
      Pd тире
      Pi відкриваючі лапки
      Pf закриваючі лапки
      Ps відкриваючі дужки
      Pe закриваючі дужки
      Po інше

  Відмітки M:
      Mc двокрапки
      Me вкладення
      Mn апострофи

  Символи S:
      Sc валюти
      Sk модифікатори
      Sm математичні
      So інше

  Розділювачі Z:
      Zl лінія
      Zp параграф
      Zs пробіл

  Інше C:
      Cc контрольні
      Cf форматування
      Cn не призначене
      Co для приватного використання
      Cs суррогати


ЯКОРЯ ^ $
---------

^ : співпадіння з початком тексту,
$ : співпадіння з кінцем тексту

    let str1 = "Mary had a little lamb";
    console.log( /^Mary/.test(str1) ); // true
    console.log( /lamb$/.test(str1) ); // true

^+$: повне співпадіння шаблона і рядка:

    let goodInput = "12:34",
        badInput  = "12:345",
        regexp    = /^\d\d:\d\d$/;
    console.log( regexp.test(goodInput) ); // true
    console.log( regexp.test(badInput) );  // false


При включеному багаторядковому режимі (прапор m) пошук здійснюється не по
початку/кінцю текста, а по початку/кінцю кожного рядка.

    let str = `1е место: Винни
               2е место: Пятачок
               3е место: Слонопотам`;
    console.log( str.match(/^\d/gm) ); // 1, 2, 3

    let str = `Винни: 1
               Пятачок: 2
               Слонопотам: 3`;
    console.log( str.match(/\d$/gm) ); // 1,2,3


МЕЖА СЛОВА \b
-------------

Межею слова є:
1. Початок тексту з першим символом \w
2. В середині тексту, якщо зліва \w, а справа - не \w, або навпаки
3. Кінець тексту з останнім символом \w

    console.log( "Hello, Java!".match(/\bJava\b/) ); // Java
    console.log( "Hello, JavaScript!".match(/\bJava\b/) ); // null

    console.log( "1 23 456 78".match(/\b\d\d\b/g) ); // 23,78


ЕКРАНУВАННЯ \
-------------

\ : екранування спецсимволів [ \ ^ $ . | ? * + ( ) /

    .  - спецсимвол
    \. - крапка
    (  - спецсимвол
    \( - дужка
    \  - спецсимвол
    \\ - коса риска

    console.log( "Глава 5.1".match(/\d\.\d/) ); // 5.1 - крапка
    console.log( "Глава 511".match(/\d.\d/) );  // 511 - будь-який символ
    console.log( "Глава 511".match(/\d\.\d/) ); // null


Особливості екранування new RegExp
----------------------------------

1. Символ шаблону екранувати не потрібно:

    console.log( "/".match(/\//) ); // '/'
    console.log( "/".match(new RegExp("/")) ); // тут екранування не потрібне

2. Символ екранування потрібно подвоювати:

    let regexp1 = new RegExp("\d\.\d");
    console.log( "Глава 5.1".match(regexp1) ); // null
    let regexp2 = new RegExp("\\d\\.\\d");
    console.log( "Глава 5.1".match(regexp2) ); // 5.1


НАБОРИ […]
----------

Кілька символів у дужках […] означає "будь-який символ із перелічених", напр.:

    [qwe] - або q, або w, або e

    console.log( "Топ хоп".match(/[тх]оп/gi) );  // "топ", "хоп"
    console.log( "Вуаля".match(/В[уа]ля/) );     // null
    console.log( "Вуаля".match(/В[уа][уа]ля/) ); // Вуаля

набори + символьні класи:

    [\s\d] - пробіл або цифра
    [\w-]  - латинстка буква, цифра, підкреслення або дефіс


Символьні класи по суті є скороченням для наборів символів:

    \d = [0-9]
    \w = [a-zA-Z0-9_]
    \s = [\t\n\v\f\r ]

Багатомовний аналог \w:

    [\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}] // Alphabetic (Alpha) – букви,
                                           // Mark (M) – акценти,
                                           // Decimal_Number (Nd) – цифри,
                                           // Connector_Punctuation (Pc) –
                                           // підкреслення,
                                           // Join_Control (Join_C) – два спец.
                                           // кода 200c и 200d для лігатур.


ДІАПАЗОНИ [0-9a-z]
------------------

    [a-z] - символи в діапазоні від a до z
    [0-5] – в діапазоні цифра від 0 до 5
    [0-9A-Za-z] - цифри, великі і малі латинські букви
    /[0-9A-Z]/i - цифри, великі і малі латинські букви

    console.log( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) ); // xAF


ВИКЛЮЧЕННЯ З ДІАПАЗОНІВ І НАБОРІВ [^…]
--------------------------------------

    [^aeyo] – будь-який символ, за винятком 'a', 'e', 'y', 'o'
    [^0-9]  – будь-який символ, за винятком цифр, = \D
    [^\s]   – будь-який непробільний символ, = \S

    // не цифри, не пробіли і не букви
    console.log( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // @, .

    console.log( 'Java'.match(/Java[^script]/) );       // null
    console.log( 'JavaScript'.match(/Java[^script]/) ); // "JavaS"


ЕКРАНУВАННЯ В НАБОРАХ І ДІАПАЗНАХ [\…]
--------------------------------------

В […] спец. символи можна використовувати без екранування в усіх випадках, крім
випадків, коли ці символи позначають щось в наборах і діапазонах.

. + ( ) не треба екранувати взагалі
- не треба екранувати усюди, де він не позначає діапазон
^ треба екранувати тільки на початку, де він позначає виключення
] екранувати не потрібно

    console.log( "1 + 2 - 3".match(/[-().^+]/g) ); // + -


СУРОГАТНІ ПАРИ В НАБОРАХ І ДІАПАЗОНАХ
-------------------------------------

для коректної роботи сурогатних пар потрібен прапор u:

    console.log( '𝒳'.match(/[𝒳𝒴]/) );  // Array [ "\ud835" ]
    console.log( '𝒳'.match(/[𝒳-𝒴]/) ); // Error: Invalid regular expression
    console.log( '𝒳'.match(/[𝒳𝒴]/u) ); // 𝒳
    console.log( '𝒴'.match(/[𝒳-𝒵]/u) ); // 𝒴


КВАНТИФІКАТОРИ x{n}
-------------------

Квантифікатри використовуються для вказання повторень.

{n}   точна кількість
{n,m} діапазон

    \d{5}     = \d\d\d\d\d     // група з 5 цифр
    \b\d{5}\b = \b\d\d\d\d\d\b // відокремлена група з 5 цифр

    console.log( "231 123456 3".match(/\d{5}/) ); //  "12345"

    \d{3,5} // група чисел від 3 до 5
    \d{3,}  // група чисел від 3 і більше

    console.log( " 12 1234".match(/\d{3,5}/) ); // "1234"
    console.log( " 12 345678".match(/\d{3,}/) ); // "345678"

    let str     = "+7(903)-123-45-67",
        numbers = str.match(/\d{1,}/g); // 7,903,123,45,67


Короткі позначення:
-------------------

+ = {1,}

    let str = "+7(903)-123-45-67";
    console.log( str.match(/\d+/g) ); // 7,903,123,45,67

? = {0,1} // робить символ не обов'язковим

    let str = "Потрібно писати color чи colour?";
    console.log( str.match(/colou?r/g) ); // color, colour

* = {0,} // символ може повторюватися багато разів або бути відсутнім

    console.log( "100 10 1".match(/\d0*/g) ); // 100, 10, 1
    console.log( "100 10 1".match(/\d0+/g) ); // 100, 10


Додаткові приклади з квантифікаторами:
--------------------------------------

    /\d+\.\d+/             // десяткові дроби
    /<[a-z][a-z0-9]*>/i    // відкриваючий тег без атрибутів
    /<\/?[a-z][a-z0-9]*>/i // відкриваючий/закриваючий тег без атрибутів
    /<[^<>]+>/g            // відкриваючий/закриваючий тег з атрибутами


РЕЖИМИ РОБОТИ КВАНТИФІКАТОРІВ: ЖАДІБНИЙ І ЛЕДАЩИЙ
-------------------------------------------------

За замовчуванням використовується жадібний варіант.

    let regexp = /".+"/g;
    let str = 'a "witch" and her "broom" is one';
    console.log( str.match(regexp) ); // "witch" and her "broom"

Суть жадібного режиму роботи: квантифікатор + порівнює символ рядка з .
(будь-яким символом) приймає його і переходить на наступну позицію. І так до
кінця. В кінці рушій розуміє, що взяв забагато, припиняє роботу з
квантифікатором, бере наступний символ шаблону і починає порівнювати його з
символами рядка, беручи їх по одному від останнього.

Ледащий режим вмикається символом ? одразу після квантифікатора: +?, ??

    let regexp = /".+?"/g;
    let str = 'a "witch" and her "broom" is one';
    console.log( str.match(regexp) ); // witch, broom

Суть ледащого режиму роботи: квантифікатор + порівнює символ рядка з .
(будь-яким символом) приймає його і переходить на наступну позицію. На наступній
позиції рушій одразу пробує обірвати роботу квантифікатора, порівнюючи символ
рядка з наступним символом шаблону, і тільки якщо нема співпадіння, рушій знову
вмикає квантифікатор на одну ітерацію.


ДУЖКОВІ ГРУПИ (…)
-----------------

Ефекти дужкових груп:
---------------------

1. Якщо після дужок поставити квантифікатор, він застусовуватиметься до всієї
   групи, а не до одного символу.

    console.log( 'Gogogo now!'.match(/(go)+/i) ); // "Gogogo"

    // пошук доменів
    let regexp = /([\w-]+\.)+\w+/g,
        str    = 'site.com my.site.com my-site.com';
    console.log( str.match(regexp) ); // site.com,my.site.com,my-site.com

    //пошук пошт
    let regexp = /[-.\w]+@([\w-]+\.)+[\w-]+/g,
        str    = 'my@mail.com @ his@site.com.uk';
    console.log( str.match(regexp) ); // my@mail.com, his@site.com.uk


2. Частину співпадіння можна помістити в окремий масив.

   Метод str.match(regexp) без прапора g повертає перше співпадіння у вигляді
   масиву з властивостями arr.index (місце співпадіння), arr.input (рядок, у
   якому здійснювався пошук) та arr[0] (шукане співпадіння). При використанні
   дужкових груп вміст кожної групи стає елементом масиву arr[1], arr[2] і т.д.

    let tag = '<h1>Hello, world!</h1>'.match(/<(.*?)>/);
    console.log( tag[0] ); // <h1>
    console.log( tag[1] ); // h1

   Групи можуть бути вкладеними:

    let str    = '<span class="my">',
        regexp = /<(([a-z]+)\s*([^>]*))>/,
        result = str.match(regexp);
    console.log(result[0]); // <span class="my">
    console.log(result[1]); // span class="my"
    console.log(result[2]); // span
    console.log(result[3]); // class="my"

   Якщо дужкова група не обов'язкова (напр. (...)?), вона все одно займає місце
   в масиві-результаті, значенням буде undefined.

    let match = 'a'.match(/a(z)?(c)?/);
    console.log( match.length ); // 3
    console.log( match[0] ); // a
    console.log( match[1] ); // undefined
    console.log( match[2] ); // undefined


matchAll
--------

При поверненні результату пошуку без прапора g, результатом буде масив з
додатковими властивостями і масивом дужкових груп (якщо вони є). Але при
використанні прапора g може повернутися не одне значення, а цілий масив значень,
в якому уже не буде додаткових властивостей і дужкових груп. Цю ситуацію може
виправити метод str.matchAll(regexp);

Метод str.matchAll(regexp)
1. повертає не масив, а об'єкт, що перебирається
2. якщо співпадінь нема, результатом буде не null, а пустий об'єкт
3. при пошуку з прапором g він повертає кожне співпадіння як масив з дужковими
   групами.

    let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);
    console.log(results); // [object RegExp String Iterator]
    console.log(results[0]); // undefined (*)
    results = Array.from(results);
    console.log(results[0]); // <h1>,h1
    console.log(results[1]); // <h2>,h2


Іменовані дужкові групи (?<name>…)
----------------------------------

Якщо регулярний вираз великий, запам'ятовувати групи за номерами не зручно.

    let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;
    let str = "2019-04-30";

    let groups = str.match(dateRegexp).groups;
    console.log("groups", groups);

    console.log(groups.year);  // 2019
    console.log(groups.month); // 04
    console.log(groups.day);   // 30


Дужкові групи + replace:
------------------------

    let str    = "John Bull",
        regexp = /(\w+) (\w+)/;
    console.log( str.replace(regexp, '$2, $1') ); // Bull, John


Іменовані дужкові групи + replace:
----------------------------------

    let str = "2019-10-30, 2020-01-01",
        regexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;
    console.log( str.replace(regexp, '$<day>.$<month>.$<year>') );
    // 30.10.2019, 01.01.2020


Виключення із запам'ятовування (?:…)+
-------------------------------------

Дужкову групу можливо виключити з переліку таких, що потрапляють до результату
arr[n]:

    let result = "Gogogo John!".match(/(?:go)+ (\w+)/i);

    console.log( result[0] );     // Gogogo John
    console.log( result[1] );     // John
    console.log( result.length ); // 2

У виключенні є побічний ефект: на такі дужки не можна посилатися в рядку заміни.


ЗВОРОТНІ ПОСИЛАННЯ В ШАБЛОНІ \N ТА \k<ім'я>
-------------------------------------------

У регулярних виразах може виникнути необхідність шукати результат співпадіння у
залежносі від рузультату з іншої частини регулярного виразу, наприклад при
пошуку парних символів (одинарних або подвійних лапок) було знайдено подвійну
лапку і тепер треба знайти другу лапку, але тепер уже точно подвійну. Вираз типу
['"](.*?)['"] не підійде. Цю проблему вирішує зворотнє посилання. Потрібно
повторюваний фрагмент у першому місці огорнути в дужки, а у другому місці цей
фрагмент замінити на \номер, який відповідатиме дужковій групі першого
фрагменту:

    /['"](.*?)['"]/g => /(['"])(.*?)\1/g


    let str = `He said: "She's the one!".`;
    console.log( str.match(/['"](.*?)['"]/g) ); // "She'
    console.log( str.match(/(['"])(.*?)\1/g) ); // "She's the one!"


ІМЕНОВАНІ ЗВОРОТНІ ПОСИЛАННЯ ?<quote>…\k<quote>
-----------------------------------------------

По аналогії до іменованих дужкових груп:

    let str = `He said: "She's the one!".`;
    console.log( str.match(/(?<quote>['"])(.*?)\k<quote>/g) ); // "She's the one!"


АЛЬТЕРНАЦІЯ |
-------------

    gr(a|e)y = gr[ae]y
    gra|ey = "gra" або "ey"

    Люблю HTML|CSS = "Люблю HTML" або "CSS".
    Люблю (HTML|CSS) = "Люблю HTML" або "Люблю CSS".


    let regexp = /html|css|java(script)?/gi,
        str    = "Сначала появился язык Java, затем HTML, потом JavaScript";
    console.log( str.match(regexp) ); // Java,HTML,JavaScript

    // пошук правильного часу у форматі "nn:nn"
    let regexp = /([01]\d|2[0-3]):[0-5]\d/g;
    console.log("00:00 23:59 25:99 1:2".match(regexp)); // 00:00, 23:59

    // знайти мови програмування
    let regexp = /Java(Script)?|C(\+\+)?|PHP/g,
        str    = "Java, JavaScript, PHP, C, C++";
    console.log( str.match(regexp) ); // Java,JavaScript,PHP,C,C++


ВИПЕРЕДЖУВАЛЬНІ ТА РЕТРОСПЕКТИВНІ ПЕРЕВІРКИ X(?=Y), X(?!Y), (?<=Y)X, (?<!Y)X
----------------------------------------------------------------------------

Дані перевірки знаходять ті шаблони, після або перед якими є інші шаблони.

X(?=Y)  : Позитивна випереджуюча   X, якщо за ним іде Y
X(?!Y)  : Негативна випереджуюча   X, якщо за ним НЕ іде Y
(?<=Y)X : Позитивна ретроспективна X, якщо він іде за Y
(?<!Y)X : Негативна ретроспективна X, якщо він НЕ іде за Y


    console.log( "XYZ".match(/X(?=Y)(?=Z)/) ); // X
    console.log( "1 индейка стоит 30€".match(/\d+(?=€)/) ); // 30
    console.log( "1 индейка стоит 30€".match(/\d+(?=\s)(?=.*30)/) ); // 1

    let str = "2 индейки стоят 60€";
    console.log( str.match(/\d+(?!€)/) ); // 2

    let str = "1 индейка стоит $30";
    console.log( str.match(/(?<=\$)\d+/) ); // 30

    let str = "2 индейки стоят $60";
    console.log( str.match(/(?<!\$)\d+/) ); // 2


Дужкові групи перевірок не включаються в масив-результат. Якщо шаблон перевірки
повинен попасти в результат, його огортають у додаткові дужки.

    let str = "1 индейка стоит 30€";
    let regexp = /\d+(?=(€|kr))/;
    console.log( str.match(regexp) ); // 30, €

    let str = "1 индейка стоит $30";
    let regexp = /(?<=(\$|£))\d+/;
    console.log( str.match(regexp) ); // 30, $


КАТАСТРОФІЧНЕ ПОВЕРНЕННЯ
------------------------

Бувають регулярні вирази, які "кладуть" систему. Це відбувається при
використанні квантифікаторів. За замовчуванням вони працюють за жадібним
принципом і захоплюють по максимуму символів, при не відповідності шаблону
починають віддавати по одному символу, поступово з'вляється кілька груп,
рушій починає комбінувати їх розмір і кількість, сильно збільшуючи кількість
варіантів. Наприклад, рядок

    console.log( '123456789!'.match(/^(\d+)*$/gi) );

буде інтерпретуватися рушієм як

    (123456789)! (12345678)9! (12345678)(9)! (1234567)(89)! (1234567)(8)(9)!
    (123456)(78)(9)!

тобто рушій з однієї групи \d+ почне помилково вичленювати багато груп \d+\d+,
\d+\d+\d+ тощо.

Варіанти вирішення проблеми:

1. Переписати регулярку, якщо це можливо.
2. Спеціальні засоби: захоплюючі квантифікатори, атомарні дужкові групи. Ці
   засоби в JS не доступні.
3. Випереджуючі перевірки (?=(\d+))\1

    console.log( "JavaScript".match(/\w+Script/));         // JavaScript   (1)
    console.log( "JavaScript".match(/(?=(\w+))\1Script/)); // null         (2)
    console.log( "JavaScript".match(/(?=(?<word>\w+))\k<word>Script/)); // (2)

   У першому прикладі жадібний квантифікатор w+ спочатку забирає весь рядок, а
   потім починає віддавати по одному символу, порівнюючи віддані символи із
   рештою шаблону.
   У другому прикладі реалізований аналог захоплюючого квантифікатора, який
   бере тільки слово цілком, а не його частину.


ПОШУК НА ЗАДАНІЙ ПОЗИЦІЇ, ПРАПОР 'y' ТА МЕТОД regexp.exec(str)
--------------------------------------------------------------

метод regexp.exec(str) шукає:

1. без прапорів g та y - перше співпадіння, так само, як str.match(regexp);
2. з прапором g - усі співпадіння, починаючи з позації, вказаної в
   regexp.lastIndex. При створренні regexp lastIndex=0 (пошук з початку), але
   його можна змінювати вручну.