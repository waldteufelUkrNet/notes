https://docs.python.org

==========

Int   : int(), int("0x12F", base=16) - в десяткову систему числення з 16-ї
Float : float()
Str   : str()

def text_prompt(msg):
  try:
    return raw_input(msg)
  except NameError:
    return input(msg)
  finally:
    print 'ok'

==========

піднесення у степінь (**), ділення націло (//) та взяття залишку від ділення (%)

==========

якщо хоч одне із значень у виразі є дійсним числом, для проведення розрахунків інтерпретатору доведеться конвертувати значення, які з ним взаємодіють, і результат також буде дійсним, навіть за відсутності у нього дробової частини.

print (2+2)**2 % 10.0
- виведе 6.0

І навпаки, якщо операнди є цілими, результат також буде цілим. Таким чином, ділення двох цілих чисел фактично також є операцією "ділення націло":

print 10/3
- виведе 3

==========

рядки можна додавати та множити на цілі числа

==========

# однорядковий коментар

"""
багаторядковий коментар
"""

==========

Логічні вирази

a < b   -- дорівнює True, якщо a менше b, інакше -- False,
a <= b  -- дорівнює True, якщо a менше або дорівнює b, інакше -- False,
a == b  -- дорівнює True, якщо a дорівнює b, інакше -- False,
a != b  -- дорівнює True, якщо a не дорівнює b, інакше -- False,
a <> b  --   - - / / - -
a >= b  -- дорівнює True, якщо a більше або дорівнює b, інакше -- False,
a > b   -- дорівнює True, якщо a більше b, інакше -- False.

x is y  -- аналог порівняння === в JS (без приведення типів)
x in y  -- строге порівняння без приведенн типів, пошук ключа в словнику

x or y  -- дорівнює True, якщо хоч 1 з x або y дорівнює True, інакше -- False,
x and y -- дорівнює True, якщо x та y обидва дорівнюють True, інакше -- False,
not x   -- дорівнює True, якщо x не дорівнює True, інакше -- False.

Логічні операції можуть застосовуватися в одному виразі із математичними. При цьому математичні мають вищий пріоритет виконання, отже будуть обраховані раніше.
Першими у виразі обчислюються значення всіх “модифікаторів” not, потім and зліва направо, потім or -- також зліва направо.

==========

Типи даних

Прості:  int, long, float, bool, str
Складні: list,

Рядок - тип-послідовність ( перебирається в циклі for, має len(), max(), min() тощо )
-----

Позначається 'str', "str", """str"""
"""str""" - аналог `` в JS: є можливість переносу рядку, використання спец символів

розбиття і склеювання рядків:
s = 'Hello world'
s = s.split(' ') # ['Hello', 'world']
s = ', '.join(s) # 'Hello, world'

шаблони:
s = 'My name is %s, I’m %s years old.' % ('Vasia', 21)

    %s -- рядок
    %d -- ціле десяткове число,
    %x, %X -- ціле шістнадцяткове число,
    %f -- дійсне число в десятковому представленні
    %e, %E -- дійсне число в експонентному представленні
    %% -- знак відсотку

Для форматування числових значень всередині “заглушок” (між % та літерою) можуть використовуватися додаткові параметри:

    + -- відображати знак числа,
    Пробіл -- додати пробіл перед додатним числом замість “+”,
    m.n -- вставити число як рядок з m символами, залишити n знаків після коми; при цьому рядок буде розширено до необхідної довжини пробілами,
    0m.n -- те саме, але рядок буде розширено до необхідної довжини нулями.



Список -- складний тип даних, впорядкована послідовність значень будь-яких типів. (Аналог масива в JS)
------

example_list = ['one', 1, 2.0, True, [0.1, 0.2, 0.3]]
example_list[0] == 'one'
example_list[1] == 1
example_list[4][1] == 0.2
example_list[5] = '5!' # присвоїли значення новому елементу

print len(example_list) # довжина списку

взяття підмасиву

example_list[i:j] -- вибере всі елементи списку з i-го (включно) по j-й (виключаючи),
example_list[i:]  -- вибере всі елементи списку з i-го (включно) до кінця,
example_list[:j]  -- вибере всі елементи списку з початку по j-й (виключаючи).
example_list[i:j:k] -- вибере кожний k-й елемент списку з i-го (включно) по j-й (виключаючи),
example_list[i::k] -- вибере кожний k-й елемент списку з i-го (включно) до кінця,
example_list[:j:k] -- вибере кожний k-й елемент списку з початку по j-й (виключно),
example_list[::k] -- вибере кожний k-й елемент списку.

range(i) -- повертає список з числами від 0 (включно) до i (виключаючи, тобто до і-1),
range(i,j) -- повертає список з числами від i (включно) до j (виключаючи, тобто до j-1),
range(i,j,k) -- повертає список, що містить кожне k-те число від і (включно) до j (виключаючи, тобто до j-1)

Якщо i чи j від’ємні, відлік для них буде проводитися з кінця послідовності (до речі, те саме стосується від’ємних індексів).
k також може бути від’ємним, що призведе до формування нового списку із зворотним порядком елементів.

x.append(y) -- додає значення y в кінець списку x
x.upper() -- змінює регістр всіх символів рядка x на верхній.
x.lower() -- змінює регістр всіх символів рядка x на нижній.
x.replace(substring_old, substring_new) -- замінює всі входження фрагменту substring_old в рядку x на substring_new
x.find(substring) -- повертає позицію входження (індекс першого символу) фрагменту substring в рядку x або -1, якщо фрагмент не знайдено.

x.reverse()

x.sort() -- сортує елементи списку x за зростанням.
x.extend(y) -- додає елементи списку y в кінець списку x.
x.insert(i, y) -- вставляє елемент y на позицію i в списку x, при цьому існуючі елементи списку зсуваються.
x.index(y) -- повертає позицію елемента y в списку x

isupper(), islower()


Тьюпл (кортеж) - те саме, що і список, тільки не змінюваний, позначається ()
-----

Словник - аналог об'єкту в JS, ключами можуть бути незмінні типи: числа, рядки або тьюпли
-------
Доступ до властивості - через квадратні дужки: dict[key]

d.clear() -- видаляє всі значення із словника d
d.copy() -- повертає копію словника d
d.get(key, default) -- повертає значення, що відповідає ключу key словника d; якщо ключ відсутній, повертає значення default
d.keys() -- повертає список ключів словника d
d.values() -- повертає список значень словника d
d.items() -- повертає список тьюплів, кожен з яких містить пару (ключ, значення) для словника d

None?

==========

Перетворення типів даних

Boolean ->:

int(True) == 1
int(False) == 0
float(True) == 1.0
float(False) == 0.0
str(True) == 'True'
str(False) == 'False'

-> Boolean:

будь-які “непорожні” значення конвертуються в True, будь-які “нульові” -- в False.

bool(None) == False
bool(0) == False
bool(0.0) == False
bool('') == False

bool(1) == True
bool(10) == True
bool(-1.1) == True
bool('False') == True
bool(-100500) == True

===========

області видимості
з локальних областей видимості можна прочитати значення із зовнішніх, але не можна їх змінити.

==========

Модулі

підключення:

1) import module            # весь модуль, без розширення '.py'

змінні і функції з модуля викликаються як властивості об'єктів: module.a

2) from module import a,b,c # зміннs/функції a, b, c з модуля module

змінні і функції з модуля викликаються по імені: a

3) з перейменуванням

from math import exp, pi, pow as math_power

Зверніть увагу: для підключення інтерпретатор шукає модулі у поточній папці. Якщо ви підключаєте модуль всередині файлу (програми або іншого модулю) -- це папка, в якій знаходиться цей файл. Якщо ви підключаєте модуль в інтерактивному режимі інтерпретатора -- це папка, в якій його було запущено. Якщо в поточній папці файл модуля не знайдено, інтерпретатор перевіряє деякий шлях, вказаний в налаштуваннях Python (відрізняється для різних операційних систем). Саме там знаходяться більшість стандартних модулів, туди ж ви можете додавати власні модулі, туди ж можна додавати модулі, знайдені в інтернеті, для використання в своїх програмах.

==========

Пакети - група модулів, винесених у одну теку, в якій присутрій файл __init__.py
Як і модулі, пакети можуть містити код, який буде виконано під час ініціалізації пакету, -- він записується в самому файлі __init__.py

import package.module # імпорт модуля module з пакунку package

==========

isinstance(x, y) -- перевіряє, чи є x значенням типу y.
sorted(x) -- повертає список - відсортовану послідовність (рядок або список), яка складається з елементів x.

Функції модулю random
random.randint(a, b) -- повертає випадкове ціле число на відрізку від a до b включно.
random.choice(x) -- повертає випадковий елемент з непорожньої послідовності (списку або рядка) x.
random.shuffle(x) -- випадковим чином “перемішує” елементи послідовності (списку або рядка) x, зберігаючи результат в x.
random.random() -- повертає випадкове дійсне число на проміжку від 0.0 (включно) до 1.0 (не включаючи).
random.uniform(a, b) -- повертає випадкове дійсне число на відрізку від a до b включно.

==========

Класи - особливий тип даних

  class Human:
    pass # цей блок коду нічого не робить

==========

Стандартний модуль datetime

Містить 5 класів:

    datetime.datetime -- для представлення одночасно дати і часу.
    datetime.date -- для представлення лише дати. Містить методи, аналогічні методам datetime для роботи з датами.
    datetime.time -- для представлення лише часу. Містить методи, аналогічні методам datetime для роботи з часом.
    datetime.timedelta -- для представлення різниці у часі, використовується для проведення арифметичних дій над датами і часом
    datetime.tzinfo -- для представлення інформації про часову зону (часовий пояс).

Повна документація до модуля доступна на сайті python (англійською мовою).


Клас datetime.datetime

Для створення об’єктів класу datetime.datetime використовується як звичайний конструктор, так і ряд методів, які належать самому класу та не потребують створення об’єктів для свого виклику.

x = datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]) -- конструктор класу. Перші 3 параметри (рік, місяць та день) є обов’язковими, інші необов’язкові і можуть задаватися як іменовані аргументи.

dt = datetime.datetime(2014, 1, 16)
dt2 = datetime.datetime(2014, 1, 16, minute=11)

x = datetime.datetime.today() -- метод класу, використовується для створення об’єкту сьогоднішньої дати (як альтернатива конструктору).

x = datetime.datetime.now([tz]) -- те ж саме, але з можливістю задати часову зону.

dt3 = datetime.datetime.today()

x = datetime.datetime.combine(date, time) -- метод класу, створює об’єкт datetime з пари об’єктів date та time

x = datetime.datetime.strptime(date_string, format) -- метод класу, створює об’єкт datetime з рядка date_string, вважаючи, що він містить дату в форматі format.

Поля об’єктів класу доступні лише для читання:

x.year -- рік (ціле число).

x.month -- місяць (ціле число від 1 до 12).

x.day -- число (ціле число від 1 до кількості днів у місяці).

x.hour -- години (ціле число від 0 до 23).

x.minute -- хвилини (ціле число від 0 до 59).

x.second -- секунди (ціле число від 0 до 59).

x.microsecond -- мікросекунди (ціле число від 0 до 1000000).

x.tzinfo -- часова зона (об’єкт класу datetime.tzinfo або None).

Методи об’єктів класу.

x.date() -- повертає об’єкт datetime.date з аналогічними даними про дату (роком, місяцем та числом).

x.time() -- повертає об’єкт datetime.time з аналогічними даними про час.

x.replace([year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]]) -- повертає новий об’єкт datetime із зміненими значеннями вказаних полів відносно об’єкту x. Для вказання конкретних полів необхідно передати їх назву як іменовані параметри.

print dt.replace(year=2013,hour=12) # datetime.datetime(2013, 1, 16, 12, 0)
print dt # datetime.datetime(2014, 1, 16, 0, 0)

x.weekday() -- повертає порядковий номер дня тижня (0 -- понеділок, 6 -- неділя).

print dt.weekday() # 3

x.isoweekday() -- повертає порядковий номер дня тижня в ISO-форматі (1 -- понеділок, 7 -- неділя).

print dt.isoweekday()    # 4

x.isocalendar() -- повертає тьюпл, що містить рік, номер тижня та номер дня тижня в ISO-форматі.

print dt.isocalendar()           # (2014, 3, 4)

x.isoformat([sep]) -- повертає рядок, що містить дату, відформатовану у форматі ISO. В якості роздільника між датою та часом використовується sep. Якщо sep не заданий, то ‘T’.

print x.isoformat()          # 2014-01-16T00:00:00

x.strftime(format) -- повертає рядок, що містить дату у форматі заданому рядком format. Точний перелік позначень для всіх можливих елементів дати можна переглянути в документації.

dt.strftime("%A, %d. %B %Y %I:%M%p")   #'Thursday, 16. January 2014 12:00AM'


Клас datetime.timedelta

x = datetime.timedelta([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]]) -- конструктор класу. Всі аргументи є необов’язковими і можуть задаватися в іменованому вигляді.

td = datetime.timedelta(hours=48)
td2 = datetime.timedelta()

Об’єкти класу містять наступні поля, доступні лише для читання:

x.days -- кількість днів у проміжку часу (ціле число від -999999999 до 999999999 включно).

x.seconds -- кількість секунд у проміжку часу (ціле число від 0 до 86399 включно).

x.microseconds -- кількість мікросекунд у проміжку часу.

Об’єкти класу мають один метод

x.total_seconds() -- повертає повну кількість секунд у проміжку часу.

print td.total_seconds()  # 172800.0

Крім того, об’єкти класу datetime.timedelta можна порівнювати, додавати та віднімати між собою, множити та ділити на ціле число, додавати то віднімати до дат (об’єктів datetime.datetime, datetime.date, datetime.time). Також об’єкти datetime.timedelta виникають при відніманні дат одна від одної.