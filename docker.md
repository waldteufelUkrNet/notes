Docker
================================================================================

Зміст
--------------------------------------------------------------------------------

- [Інфо](#info)
- [Робота з образами](#images)
- [Робота з контейнерами](#cont)
- [Doсkerfile - інструкція для створення образу](#dfile)
- [.dockerignore - список файлів, не потрібних в образі](#dignore)
- [Змінні оточення](#vars)
- [Makefile](#mfile)
- [Томи](#volumes)
    - [Використання томів для livereload під час розробки](#reload)
- [Деплой](#deploy)
- [Зв'язування контейнерів](#bind)
    - [ключ --link, приклад.](#link)
    - [Docker Compose](#compose)
        - [docker-compose.yml + Doсkerfile](#yml+df)
- [Посилання](#links)


Інфо                                                           <i id="info"></i>
--------------------------------------------------------------------------------

**Docker** - це технологія створення і управління контейнерами. Контейнери
придумані для того, щоб ізолювати код, розташований в них, і гарантувати
однаковість його виконання на різних машинах з різними операційними системами.
Єдине, що треба,- це наявність самого docker на машині (він має бути запущеним).

**Docker** дозволяє ізолювати застосунки, не створюючи під кожен з них свою
віртуальну машину. За його допомогою можна не запускати напр. сервер nginx
напряму, а запустити docker-контейнер, в якому, як в матриці, буде запущений
свій екземпляр nginx. Ззовні для операційної системи цей екземпляр буде не
видимим, операційна система просто виконуватиме **Docker** як один зі своїх
процесів.

Застосунки, запущені з різних контейнерів навіть на одній машині, спілкуються
між собою по мережі, через мережеві адреси.

Ключовими поняттями **Docker** є **рушій (engine), образ (image), контейнер
(container)** та **том (volume)**. **Рушій** - це запущений екземпляр програми
**Docker**, без нього доступ до образів і контейнерів не можливий. **Образ**
можна порівняти з iso-образом операційної системи, а **контейнер** - відповідно
із встановленим і запущеним екземпляром операційки. **Образи** або
завантажуються з репозиторію https://hub.docker.com/, або створюються
власноручно за допомогою файла **Doсkerfile**, в якому прописуються потрібні
команди. До образів і контейнерів можна звертатися за іменами або
ідентифікаторами.

**Томи** - це спеціальні сховища даних, які знаходяться за межами образів і
контейнерів. Для розуміння їх суті підійде аналогія з диском D комп'ютера: на
ньому просто зберігаються дані, а при переустановці windows затирається диск C
(контейнер), але сам диск D не форматується. По суті, том - це зовнішня тека на
комп'ютері, підключена до контейнерного застосунку для отримання і збереження
даних.

подивитися доступні команди **Docker**:
```shell
docker
```


Робота з образами                                            <i id="images"></i>
--------------------------------------------------------------------------------

переглянути наявні образи:
```shell
docker image ls
docker images
```

завантажити образ з репозиторію (якщо цього не зробити, **Docker** це зробить
сам, коли буде читати **Doсkerfile**):
```shell
docker pull image_name
```

згенерувати образ, вказаний в **Doсkerfile** (. - шлях до файлу):
```shell
docker build .
```

при генерації можна вказати ім'я образу та версію (в таблиці образів вона
записується в колонку TAG):
```shell
docker build -t image_name:image_version .
```

видалити образ:
```shell
docker rmi image_id 
```

клонувати образ:
```shell
docker tag old_name new_name
```

створити образ із контейнера (це може бути корисним при зміні контейнера, напр.
доустановці пакетів, і необхідності використання його у подальшому; якщо цього
не зробити, то при кожному запуску контейнера доведеться наново встановлювати
пакети і робити потрібні налаштування):
```shell
docker commit container_id image_name
```

створений образ можна залити на репозиторій **Docker** (для цього потрібно
зареєструватися нa **Docker**):
```shell
docker push user_name/image_name
```


Робота з контейнерами                                          <i id="cont"></i>
--------------------------------------------------------------------------------

подивитися список усіх контейнерів:
```shell
docker ps -a
```

подивитися список запущених контейнерів:
```shell
docker ps
```

вивести ідентифікатори усіх контейнерів:
```shell
docker ps -a -q
```

>**Контейнер відкритий доти, поки працює застосунок. Як тільки застосунок
завершився, контейнер закривається**

> **Запустити контейнер можна двома шляхами: або командою *run image*, або
командою *start container***. Відмінність полягає у тому, що при використанні
команди ***start*** запускається уже наявний контейнер, а команда ***run***
спочатку створює контейнер на основі образа, а потім його запускає. При
повторному використанні команди ***run*** буде створений ще один аналогічний
контейнер (щоб цього уникнути, потрібно використовувати ключ ***--rm***, який
видалить контейнер після закриття).

запустити контейнер напряму:
```shell
docker start container
```

запустити контейнер на основі образа:
```shell
docker run image
```

запустити контейнер в інтерактивному режимі (поки контейнер запущений,
консоль блокується):
```shell
docker run -it image
```

запустити контейнер у фоновому режимі (запущений контейнер не блокує консоль):
```shell
docker run -d image
```

запустити контейнер з доступом до localhost. -p - порт, перші 3000 - порт для
localhost, другі 3000 - порт, прописаний у контейнері
```shell
docker run -d -p 3000:3000 image_id
```

при запуску образів можна давати ім'я контейнеру, прапор --rm говорить про те,
що контейнер буде видалений після зупинки:
```shell
docker run -d -p 3000:3000 --name container_name --rm image
```

??? завершити роботу контейнера:
```shell
exit
```

завершити роботу контейнера:
```shell
docker stop container
```

видалити контейнер:
```shell
docker rm container
```

видалити всі не активні контейнери:
```shell
docker container prune
```
або
```shell
docker rm $(docker ps -qa)
```

приєднатися до запущеного контейнера:
```shell
docker attach container
```


Doсkerfile - інструкція для створення образу                  <i id="dfile"></i>
--------------------------------------------------------------------------------

Коренем проекту **Docker** вважається директорія, де лежить файл **Doсkerfile**.
Кожного разу після зміни **Doсkerfile** потрібно перезбирати образ.

Приклад **Doсkerfile** (створення образу з якого потім створиться контейнер):
```
FROM node              # image_name, якщо такого нема, Docker качає його з
                       # репозиторія, якщо його нема в репозиторії, буде помилка
WORKDIR /app           # шлях до файлів у образі
COPY . .               # скопіювати локальні файли в образ з кореня в корінь або
                       # місце, вказане в WORKDIR образа. Можна й інші варіанти,
                       # напр. COPY . /app (якщо нема WORKDIR)
EXPOSE 3000            # вибір порта
RUN npm install        # запустити команду після зібрання образу
CMD ["node", "app.js"] # виконання команд після запуску образу
```

оптимізований приклад (при перекомпіляції образу node-модулі братимуться з кешу):
```
FROM node              
WORKDIR /app
COPY package.json /app
RUN npm install
COPY . .
EXPOSE 3000
CMD ["node", "app.js"]
```

.dockerignore - список файлів, не потрібних в образі        <i id="dignore"></i>
--------------------------------------------------------------------------------

приклад **.dockerignore**:
```
node_modules
.git
Dockerfile
```


Змінні оточення                                                <i id="vars"></i>
--------------------------------------------------------------------------------

1. записуються в **Doсkerfile**:
   ```
   ENV PORT 4200
   EXPOSE $PORT
   ```
   ```shell
   docker run -d -p 3000:4200 --rm --name container_name image
   ```

2. прописуються в консолі:
   ```shell
   docker run -d -p 3000:80 --rm -e PORT=80 --name container_name image
   ```

3. прописуються у файлі **.env**:
   ```
   PORT=3000
   ```

   ```shell
   docker run -d -p 3000:4200 --rm --name container_name --env-file ./config/.env image
   ```


Makefile                                                      <i id="mfile"></i>
--------------------------------------------------------------------------------

**Makefile** - файл з інструкціями, щось аналогічне до секції **scripts** файла
**package.json**. Записується в корінь проекту.

Приклад **Makefile**:

```
run:
  docker run -d -p 3000:4200 --rm --name container_name --env-file ./config/.env image
stop:
  docker stop container
```

запуск команд в консолі (для цього повинен бути встановлений make):
```shell
make run
make stop
```


Томи                                                        <i id="volumes"></i>
--------------------------------------------------------------------------------

**Томи** - це теки на локальній машині (не знаходяться ні в образах, ні в
контейнерах), можуть монтуватися в контейнери. Призначені для збереження даних,
навіть якщо контейнер був видалений. Бувають анонімні та іменовані. Шляхи до
томів прописуються в **Doсkerfile**:

```
VOLUME ["/app/path/to/volume"]
```

Для використання тому його потрібно прописати в команді у форматі абсолютний
шлях до теки зовні (зі сторони розробника):шлях до теки відносно контейнера,
напр. ```D:/files/work_area/testProject/api:/usr/src/app```. Також можна явно
створити том і його примонтувати:
```shell
docker volume create volume_name
docker run -d -p 3000:4200 -v volume_name:/path/to/volume --rm --name container_name image
```


### Використання томів для livereload під час розробки       <i id="reload"></i>

**Makefile**:
```
run-dev:
  docker run -d -p 3000:4200 -v "/absolute/path/to/volume:/app" -v /app/node_modules -v volume_name:/app/path/to/volume --rm --name container_name image
```
В коді вище додані том для node-модулів та анонімний том. Після запуску команди
при зміні коду в браузері потрібно натискати ctrl+f5.


Деплой                                                       <i id="deploy"></i>
--------------------------------------------------------------------------------

1. залити образ в docker hub:
   ```shell
   docker tag local_image docker_hub_user_name/image_name
   docker push docker_hub_user_name/image_name
   ```

2. на vps:
   ```shell
   docker pull docker_hub_user_name/image_name
   docker run -d -p 80:3000 --name container_name --rm docker_hub_user_name/image_name
   ```

3. в браузері перейти на ip vps


Зв'язування контейнерів                                        <i id="bind"></i>
--------------------------------------------------------------------------------

Часто виникає потреба розгорнути застосунок, розбитий на кілька контейнерів,
напр. сервер баз даних і виконуваний код. Для цього є кілька можливостей:
1. ключ **--link**
2. **Docker Compose**


### ключ ***--link***, приклад.                                <i id="link"></i>

Спочатку встановлюємо контейнер з сервером баз даних **MariaDB**:
```shell
docker run --name some-mariadb-name -e MYSQL_ROOT_PASSWORD=my_password -d mariadb
```

Встановлюємо образ з **adminer**, розгортаємо контейнер і прив'язуємо до нього
контейнер з СУБД:
```shell
docker run --link some-mariadb-name:db -p 8080:8080 adminer
```

Прапор ```--link some-mariadb-name:db``` означає, що при запуску образу
контейнер adminer повинен з'єднатися з контейнером some-mariadb-name, і 
посилання на контейнер some-mariadb-name всередині контейнера adminer повинне
бути позначена як ```db```. Для цього adminer в контейнері у файлі
```erc/hosts``` створює новий запис ```ip-some-mariadb-name : db```.


### Docker Compose                                          <i id="compose"></i>

**Docker Compose** є надбудовою над **Docker**, яка дозволяє автоматизовано
запускати застосунок, який розбитий на кілька контейнерів, без потреби запускати
кожен контейнер вручну.

Для його використання в корені проекту потрібно створити файл
**docker-compose.yml** з інструкціями для запуску.


приклад файла **docker-compose.yml**:
```yaml
version: '3.1' # версію треба розраховувати, знаючи свої версії docker i docker-compose (в документації є таблиці)

services:
  db:
    image: mariadb
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD=my_password
    volumes:
      - ./databases:/var/lib/mysql
  adminer:
    image: adminer
    restart: always
    ports:
      - 8080:8080
```

запуск застосунку у фоновому режимі:
```shell
docker-compose up -d
```

зупинка застосунку:
```shell
docker-compose down
```

подивитися запущені контейнери:
```shell
docker-compose ps
```


#### docker-compose.yml + Doсkerfile                         <i id="yml+df"></i>

У такій ситуації кореневий файл **docker-compose.yml** має перевагу над
**Doсkerfile**, який можна з кореня видалити (все-одно він не робочий).

Змінюємо файл **docker-compose.yml** Для цього для кожного контейнера створюємо
піддиректорію, де прописуємо потрібні **Doсkerfile**. В цих файлах прописуємо
директиву ```FROM``` з тим, що було вказано у файлі **docker-compose.yml** у
секції image, а саму секцію image замінюємо на секцію build і в ній вказуємо
шлях до потрібного **Doсkerfile**:
```yaml
version:

services:
  db:
    build: ./db
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD=my_password
    volumes:
      - ./databases:/var/lib/mysql
  adminer:
    build: ./adminer
    restart: always
    ports:
      - 8080:8080
```

зібрати і запустити проект:
```shell
docker-compose build
docker-compose up
```

Посилання                                                     <i id="links"></i>
--------------------------------------------------------------------------------

1. [Офіційний сайт](https://www.docker.com/)
2. [Youtube: Зачем нужен и как работает Docker — ликбез](https://www.youtube.com/watch?v=KS80Knz-1Z4)
3. [Youtube: Основы Docker. Большой практический выпуск](https://www.youtube.com/watch?v=QF4ZF857m44)
4. [Youtube: Docker для Начинающих - Полный Курс [2021]](https://www.youtube.com/watch?v=n9uCgUzfeRQ&t=133s)
5. [Youtube: Docker уроки для начинающих от А до Я - что такое docker ?](https://www.youtube.com/watch?v=EbEZgdTOHzE&list=PLD5U-C5KK50XMCBkY0U-NLzglcRHzOwAg)