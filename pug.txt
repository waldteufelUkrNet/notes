Онлайн-конвертер
================

https://html2jade.org/
https://html2pug.org/


Установка
=========

npm install pug
npm install pug-cli -g
pug --help


Основи роботи
=============

pug index.pug             // одноразова мініфікована компіляція
pug -w index.pug          // слідкування, мініфікований результат
pug --pretty index.pug    // одноразова не мініфікована компіляція
pug -w --pretty index.pug // слідкування, не мініфікований результат


Синтаксис
=========

Вкладеності у файлі оформляються або пробілами, або табами. Якщо зробити
вперемішку - буде помилка.

1.1. Коментарі

  // comment  - такі коментарі конвертуються в html-коментарі <!-- comment-->
  //- comment - такі коментарі залишаються в pug-файлі

1.2. багаторядкові коментарі

body
  //-
    Comments for your template writers.
    Use as much text as you want.
  //
    Comments for your HTML readers.
    Use as much text as you want.

1.3. Коментарі з умовами

pug:
  doctype html

  <!--[if IE 8]>
  <html lang="en" class="lt-ie9">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <html lang="en">
  <!--<![endif]-->

  body
    p Supporting old web browsers is a pain.

  </html>

html:
  <!DOCTYPE html>
  <!--[if IE 8]>
  <html lang="en" class="lt-ie9">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <html lang="en">
  <!--<![endif]-->

  <body>
    <p>Supporting old web browsers is a pain.</p>
  </body>

  </html>

2. Відсутність закриваючих тегів і гострих дужок (<>)

 div         |  <div>
   p Hello,  |    <p>Hello,</p>
   p Word!   |    <p>Word!</p>
             |  </div>


3.1. Атрибути - у круглих дужках, якщо атрибутів багато, їх можна писати колонкою

  div(class="className" id="id1")
  img(src="../image.png")

  input(
    type='checkbox'
    name='argument'
    data-validation="true"
    checked
  )

3.2. За замовчуванням усі спец.символи в атрибутах екрановані (для запобігання
  атак cross site scripting). Для не екранованих символів - !=

  div(class="<code>")  | <div class="&lt;code&gt;"></div>
  div(class!="<code>") | <div class="<code>"></div>

3.3. Логічні атрибути

pug:
  input(type='checkbox' checked)
  input(type='checkbox' checked=true)
  input(type='checkbox' checked=false)
  input(type='checkbox' checked=true.toString()

html (якщо в Pug не було doctype):
  <input type="checkbox" checked="checked" />
  <input type="checkbox" checked="checked" />
  <input type="checkbox" />
  <input type="checkbox" checked="true" />

html (якщо в Pug був doctype):
  <input type="checkbox" checked>
  <input type="checkbox" checked>
  <input type="checkbox">
  <input type="checkbox" checked="checked">

3.4. атрибути стилів

pug:
  a(style={color: 'red', background: 'green'})

html:
  <a style="color:red;background:green;"></a>

3.5. атрибути через об'єкт + &attributes (автоматично не екрануються)

pug:
  div#foo(data-bar="foo")&attributes({'data-foo': 'bar'})
  - let attributes = {};
  - attributes.class = 'baz';
  div#foo(data-bar="foo")&attributes(attributes)

html:
  <div id="foo" data-bar="foo" data-foo="bar"></div>
  <div class="baz" id="foo" data-bar="foo"></div>


4.1. Класи - або як атрибути у дужках, або через крапку

  div(class="col-md-6 col-xl-3")
  div.col-md-6.col-xl-3

4.2. класи через масив js

pug:
  - let classes = ['foo', 'bar', 'baz']
  a(class=classes)
  //- the class attribute may also be repeated to merge arrays
  a.bang(class=classes class=['bing'])

html:
  <a class="foo bar baz"></a>
  <a class="bang foo bar baz bing"></a>

4.3. класи через об'єкт з логічною перевіркою

pug:
  - let currentUrl = '/about'
  a(class={active: currentUrl === '/'} href='/') Home
  a(class={active: currentUrl === '/about'} href='/about') About

html:
  <a href="/">Home</a>
  <a class="active" href="/about">About</a>


5. id - або як атрибути у дужках, або через хештег

  div(id='id1')
  div#id1


6. теги без класів і id відділяються від контенту пробілом, якщо контенту
   багато, після тегу - крапка і контент з нового рядку з відступом, або тег без
   крапки, але тоді новий рядок починається з вертикальної лінії

  p Lorem ipsum dolor sit amet
  p.
    Lorem ipsum dolor sit amet…
  p
    | Lorem ipsum dolor sit amet…


7. inline скрипти і стилі - через крапку

  script.
    let a = 1;
    let b = 2;
    let c = a+b;

  style.
    .someClass {
      background-color: red;
    }


8. include - підключення файлів pug, css, js, filtered text

  include path/to/file/index.pug

  style
    include path/to/file/index.css

  script
    include path/to/file/index.js

  body
    include:markdown-it article.md

JavaScript in Pug
=================

JS-код в pug буває 3х типів:
1. не буферизований (-), не потрапляє в код
2. буферизований (=), виконує скрипт і результат вставляє в код. Екранує
3. не екранований буферизований (!=), виконує скрипт і результат вставляє в код.
   Не екранує

1. не буферизований (-)
-----------------------
pug:
  - for (let x = 0; x < 3; x++)
    li item

html:
  <li>item</li>
  <li>item</li>
  <li>item</li>

pug:
-
  let list = ["Uno", "Dos", "Tres",
              "Cuatro", "Cinco", "Seis"]
  each item in list
    li= item

html:
  <li>Uno</li>
  <li>Dos</li>
  <li>Tres</li>
  <li>Cuatro</li>
  <li>Cinco</li>
  <li>Seis</li>

2. буферизований (=)
--------------------

pug:
  p
    = 'This code is <escaped>!'

html:
  <p>This code is &lt;escaped&gt;!</p>

pug:
  p= 'This code is' + ' <escaped>!'
  p(style="background: blue")= 'A message with a ' + 'blue' + ' background'

html:
  <p>This code is &lt;escaped&gt;!</p>
  <p style="background: blue">A message with a blue background</p>

3. не екранований буферизований (!=)
------------------------------------

pug:
  p
    != 'This code is <strong>not</strong> escaped!'

html:
  <p>This code is <strong>not</strong> escaped!</p>

pug:
  p!= 'This code is' + ' <strong>not</strong> escaped!'

html:
  <p>This code is <strong>not</strong> escaped!</p>


змінні
------

  - let url = 'pug-test.html';   | <a href="/pug-test.html">Link</a>
  a(href='/' + url) Link         | <a href="https://example.com/">Another link</a>
  - url = 'https://example.com/' |
  a(href=url) Another link       |


інтерполяція
------

pug:
  - let btnType = 'info'
  - let btnSize = 'lg'
  button(type='button' class='btn btn-' + btnType + ' btn-' + btnSize)
  button(type='button' class=`btn btn-${btnType} btn-${btnSize}`)

html:
  <button class="btn btn-info btn-lg" type="button"></button>
  <button class="btn btn-info btn-lg" type="button"></button>


умови
-----

1. case-when-(break)-default - аналог JS switch-case-break
----------------------------

pug:
  - let friends = 10
  case friends
    when 0
      p you have no friends
    when 1
      p you have a friend
    when 2
    when 3
    when 4
      p you have some friends
    default
      p you have #{friends} friends

html:
  <p>you have 10 friends</p>

в pug, на відміну від js, в кінці кожного розгалудження break не потрібен:
виконання коду не "провалюється" у наступні when. Break повністю припиняє
читання усіх when.

pug:
- let friends = 0
case friends
  when 0
    - break
  when 1
    p you have very few friends
  default
    p you have #{friends} friends


інший тип синтаксису - через двокрапку
  - let friends = 1
  case friends
    when 0: p you have no friends
    when 1: p you have a friend
    default: p you have #{friends} friends

html:
  <empty>

2. if-else
----------

pug:
  - let user = {description: 'foo bar baz'}
  - let authorised = false
  #user
    if user.description
      h2.green Description
      p.description= user.description
    else if authorised
      h2.blue Description
      p.description.
        User has no description,
        why not add one...
    else
      h2.red Description
      p.description User has no description

html:
  <div id="user">
    <h2 class="green">Description</h2>
    <p class="description">foo bar baz</p>
  </div>

3. unless "поки ні" == if !(condition)
---------

unless user.isAnonymous              | if !user.isAnonymous
  p You're logged in as #{user.name} |   p You're logged in as #{user.name}


цикли
-----

1. each-in
----------

pug:
  ul
    each val, index in ['zero', 'one', 'two']
      li= index + ': ' + val

html:
  <ul>
    <li>0: zero</li>
    <li>1: one</li>
    <li>2: two</li>
  </ul>

pug:
  ul
    each val, key in {1: 'one', 2: 'two', 3: 'three'}
      li= key + ': ' + val

html:
  <ul>
    <li>1: one</li>
    <li>2: two</li>
    <li>3: three</li>
  </ul>

pug:
  - let values = [];
  ul
    each val in values
      li= val
    else
      li There are no values

html:
  <ul>
    <li>There are no values</li>
  </ul>

2. while
--------

pug:
  - let n = 0;
  ul
    while n < 4
      li= n++

html:
  <ul>
    <li>0</li>
    <li>1</li>
    <li>2</li>
    <li>3</li>
  </ul>

3. for-in
---------

pug:
  - let data = ["name1", "name2", "name3"];
  div
    h1 header
    for name in data
      p= name

html:
  <div>
    <h1>header</h1>
    <p>name1</p>
    <p>name2</p>
    <p>name3</p>
  </div>

4. for - не є частиною pug, тому потрібно екранувати -

pug:
  - let x = 3;
  div
    ul
      - for (let i = 1; i <= x; i++) {
        li Hello
      - }

html:
  <div>
    <ul>
      <li>Hello</li>
      <li>Hello</li>
      <li>Hello</li>
    </ul>
  </div>

Наслідування
============

Суть наслідування в тому, щоб створити файл-шаблон з типовою структурою і
місцями для вставки контенту. Інші pug-файли можуть його наслідувати. Вони не
мають власної структури, а лише назви-відповідники до місць вставки в шаблоні зі
своїм специфічним контентом. В результаті рендерингу утворюється файл html зі
структурою шаблону і контентом pug-файла.


файл-шаблон template.pug:

  doctype html
  html
    head
      // title, meta, links, scripts
    body
      main.main

        include path/to/sub-file.pug // шлях відносно файлу-шаблону

        #book-content

          include ../modules/loader/loader.pug
          block first-screen  // ключове слово block + назва блоку
          block name          // це все - місця для вставки

pug-файл:

  extends path/to/template.pug // шлях відносно файлу

  block first-screen
    // some content

  block name
    // some content


Якщо у шаблоні або у файлі є теги з адресами (script, link, img), їхні шляхи
вказуються відносно скомпільованого html-файлу.

За замовчуванням вставка блоку перезатирає такий же блок в шаблоні (допускається
не пустий блок, з дефолтним вмістом, однаковим для усіх спадкоємців). Цю дію
можна замінити дозаписом на початок/кінець.

pug-файл:

  extends path/to/template.pug // шлях відносно файлу

  block append first-screen // = append first-screen (без block)
    // some content

  block prepend name        // = prepend name (без block)
    // some content


Інтерполяція
============

1. рядкова екранована інтерполяція

pug:
  - let title = "On Dogs: Man's Best Friend";
  - let author = "enlore";
  - let theGreat = "<span>escape!</span>";

  h1= title
  p Written with love by #{author}
  p This will be safe: #{theGreat}

html:
  <h1>On Dogs: Man's Best Friend</h1>
  <p>Written with love by enlore</p>
  <p>This will be safe: &lt;span&gt;escape!&lt;/span&gt;</p>

pug:
  p No escaping for #{'}'}!

html:
  <p>No escaping for }!</p>

pug:
  p Escaping works with \#{interpolation}
  p Interpolation works with #{'#{interpolation}'} too!

html:
  <p>Escaping works with #{interpolation}</p>
  <p>Interpolation works with #{interpolation} too!</p>

2. рядкова не екранована інтерполяція

pug:
  - let riskyBusiness = "<em>Some of the girls are wearing my mother's clothing.</em>";
  .quote
    p Joel: !{riskyBusiness}

html:
  <div class="quote">
    <p>Joel: <em>Some of the girls are wearing my mother's clothing.</em></p>
  </div>

3. інтерполяція тегів

pug:
  p.
    This is a very long and boring paragraph that spans multiple lines.
    Suddenly there is a #[strong strongly worded phrase] that cannot be
    #[em ignored].
  p.
    And here's an example of an interpolated tag with an attribute:
    #[q(lang="es") ¡Hola Mundo!]

html:
  <p>This is a very long and boring paragraph that spans multiple lines.
    Suddenly there is a <strong>strongly worded phrase</strong> that cannot be
    <em>ignored</em>.</p>
  <p>And here's an example of an interpolated tag with an attribute:
    <q lang="es">¡Hola Mundo!</q></p>


Міксини
=======

1.
pug:
  //- Declaration
  mixin list
    ul
      li foo
      li bar
      li baz
  //- Use
  +list
  +list

html:
  <ul>
    <li>foo</li>
    <li>bar</li>
    <li>baz</li>
  </ul>
  <ul>
    <li>foo</li>
    <li>bar</li>
    <li>baz</li>
  </ul>

2. міксини здатні приймати аргументи

pug:
  mixin pet(name)
    li.pet= name
  ul
    +pet('cat')
    +pet('dog')
    +pet('pig')

html:
  <ul>
    <li class="pet">cat</li>
    <li class="pet">dog</li>
    <li class="pet">pig</li>
  </ul>

3. міксини можуть приймати блоки pug і перетворювати їх на свій контент

pug:
  mixin article(title)
    .article
      .article-wrapper
        h1= title
        if block
          block
        else
          p No content provided

  +article('Hello world')

  +article('Hello world')
    p This is my
    p Amazing article

html:
  <div class="article">
    <div class="article-wrapper">
      <h1>Hello world</h1>
      <p>No content provided</p>
    </div>
  </div>
  <div class="article">
    <div class="article-wrapper">
      <h1>Hello world</h1>
      <p>This is my</p>
      <p>Amazing article</p>
    </div>
  </div>

4. міксини і атрибути

pug:
  mixin link(href, name)
    //- attributes == {class: "btn"}
    a(class!=attributes.class href=href)= name

  +link('/foo', 'foo')(class="btn")

html:
  <a class="btn" href="/foo">foo</a>

pug:
  mixin link(href, name)
    a(href=href)&attributes(attributes)= name

  +link('/foo', 'foo')(class="btn")

html:
  <a class="btn" href="/foo">foo</a>

5. Дефолтні аргументи

  //- Declaration
  mixin article(title='Default Title')
    .article
      .article-wrapper
        h1= title

6. Залишкові аргументи

  mixin list(id, ...items)
    ul(id=id)
      each item in items
        li= item

  +list('my-list', 1, 2, 3, 4)