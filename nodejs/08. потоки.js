////////////////////////////////////////////////////////////////////////////////

// Потік - js-об'єкт, який отримує інформацію про дані і вміє з цими даними
// працювати.

// Вбудовані класи stream.Readable тa stream.Writable, самі використовується
// рідко, в основному їх нащадки:
//   fs.ReadStream / fs.WriteStream
//   server.on('request', …req… ) / server.on('request', …res… )

//   res instanceof http.Server.Responce instenceof stream.Writable

// також є інші типи потоків


// stream.ReadStream

// Коли відкривається новий потік new stream.ReadStream, створюється об'єкт,
// який підключається до даних і після прочитання порції даних генерує подію
// "readable" (прочитані дані доступні через метод read()), і переходить в режим
// очікування, з якого виходить викликом методу read(). Коли дані закінчуються,
// виникає подія "end".
// Для обриву потоку є метод destroy().
// При відкритті потоку, файл зчитується не повністю, а порціями по 65536 байт
// (64 Кб).
// Для потоку fs.ReadStream є дві додаткові події - "open" та "close". Коли файл
// дочитаний, "end" -> "close", якщо файл не дочитаний (помилка, destroy()),
// події "end" не буде.


// Відмінність між fs.readFile та fs.ReadStream:

// fs.readFile спочатку прочитає ВЕСЬ файл, потім викличе callback, а
// fs.ReadStream читає файл потоком, тобто частинками по 64 кб, в результаті
// чого fs.readFile може з'їсти усю пам'ять і затупити сервер, а fs.ReadStream
// утворює окремий потік і не напружує сервер. Хоча і перше, і друге є
// асинхронним кодом.


// stream.Writeable

// Спочатку створюється об'єкт потоку. Для передачі даних використовується метод
// write(data), причому дані додаються до спеціальної властивості потоку -
// буфера. Якщо буфер не великий, дані циклом дозаписуються в нього ( кожний
// виклик write(data) повертає true). Відсилку даних потік виконує самостійно.
// Якщо ж буфер був заповнений, або було передано одразу багато даних, метод
// write(data) поверне false. У цьому випадку треба зачекати з передачею даних і
// дочекатися події "drain" (потік її генерує, коли всі дані з буфера були
// відіслані). Коли усі дані передані і write(data) повернув true, потрібно
// викликати метод end([data]), якщо його визвати з аргументом, він викличе метод
// write(data). По завершенні усіх операцій згенерується подія "finish", аналог
// "end" у stream.ReadStream (вони названі навмисно по різному, бо є
// потоки-дуплекси, які здатні читати і писати і їм важлива різниця в методах).
// Для обриву потоку є метод destroy(). Якщо його викликати, подія "finish" не
// відбудеться.

// У fs.Writeable також є подія 'close', вона сигналізує про обрив передачі
// даних (у fs.ReadStream подія з аналогічною назвою сигналізує про кінець
// зчитування файлу).
// Якщо на стороні клієнта відбудеться обрив зв'язку, на стороні сервера подія
// "close" fs.readFile-потоку не спрацює (адже сервер нормально все зчитує).
// Виходить так, що передача файлу завершитися не може і зависає: займається
// пам'ять буфера, не помирають усі залежності із замикань. Якщо клієнт кілька
// разів повторить дії, які призведуть до повторення такої ситуації, сервер
// сильно напружиться. Щоб цього уникнути, потрібно відловлювати подію "close"
// на пишучому потоці fs.Writeable і робити обрив читаючого потоку fs.ReadStream
// його методом destroy().


// Метод pipe():
// зчитує дані з потоку stream.ReadStream і записує в потік (потоки)
// stream.Writeable

  Readable.pipe(Writable1);
  Readable.pipe(Writable2);