////////////////////////////////////////////////////////////////////////////////

// Асинхронна розробка

// 1. Не блокує інтерпретатор
// 2. Не працює try … catch ( помилки в callback(err) )
// 3. Помилки потрібно обробляти обов'язково, інакше скрипт почне глючити (він
//    не ляже, як при синхронній розробці).
// 4. В асинхронних методах є функція-колбек. Існує угода, що перший її аргумент
//    - об'єкт помилки, другий - результат. Якщо метод завершиться з помилкою,
//    буде визваний callback(err), якщо успішно - callback(null, result).


// Бібліотека LibUV

// Написана на С і вбудована в Node.js.
// Відповідає:
// 1. Кросплатформенна робота з файлами, операціями введення-виведення, мережею.
// 2. Підтримка основного цикла подій:
//    ( .. -> JS -> таймери, введення-виведення -> JS -> .. ).


// Поки JS зайнятий обробкою коду, усі події встають у чергу LibUV, і чекають,
// поки інтерпретатор JS не звільниться. Щоб не було тривалих зависань через
// важкі задачі в JS, можна:
// 1. Виділити важкі задачі в окремі процеси
// 2. Виділити важкі задачі в окремі потоки
// 3. Запустити сервер Node.js в режимі великої кількості процесів (напр.
//    cluster)
// 4. Розбити важкі задачі на частини із setTimeout, тоді між цими таймерами
//    будуть оброблятися і обробники в LibUV


// ***
server.close() // сервер припиняє слухати порт (нові запити не приймаються), але
               // поки є ще якісь старі обробники, сервер продовжує їх
               // обслуговувати. Як тільки усі обробники виконані, сервер
               // закривається повністю.

process.memoryUsage() // виводить в консоль використання пам'яті

process.exit() // повна зупинка основного циклу подій


// Таймери

let timer = setInterval(…);
timer.unref() // вказує бібліотеці libUV, що таймер другорядний і його не треба
              // враховувати при перевірці можливості завершення процесу.
timer.ref()   // зворотна до timer.unref() дія

process.nextTick(function(){…}) // якісна заміна setTimeout(function(){},0):
                                // код виконається асинхронно, після виконання
                                // поточного коду, але гарантовано перед
                                // можливими наступними подіями
                                // введення-виведення або таймерами, причому,
                                // якщо є вкладені рекурсивні виклики
                                // nextTick, вони виконуватимуться одразу, теж
                                // перед подіями і таймерами. Тобто nextTick є
                                // асинхронним, але пригальмовує цикл подій

setImmediate(function(){…}) // асинхронне виконання, після виконання поточного
                            // JS-коду та усіх уже запланованих на виконання
                            // асинхронних задач. Якщо є вкладені виклики,
                            // вони, на відміну від process.nextTick, не
                            // блокують цикл подій, а виконуються на наступних
                            // ітераціях цього циклу


// Коди помилок (напр ENOENT) визначаються бібліотекою LibUV
// https://github.com/nodejs/node-v0.x-archive/blob/3d3d48d4b78d48e9b002660fc045ba8bb4a96af2/deps/uv/include/uv.h#L65
// http://docs.libuv.org/en/v1.x/errors.html