Початок роботи
--------------------------------------------------------------------------------

Sequelize - це ORM-бібліотека для роботи з:
  - PostgreSQL,
  - MySQL,
  - MariaDB,
  - SQLite,
  - Microsoft SQL Server,
  - Amazon Redshift,
  - Snowflake’s Data Cloud.


### Установка

```shell
npm install --save sequelize
```

Також потрібно встановити один з пакетів для підтримки діалекту:

```shell
npm install --save pg pg-hstore # Postgres
npm install --save mysql2
npm install --save mariadb
npm install --save sqlite3
npm install --save tedious      # Microsoft SQL Server
```


### Створення об'єкту підключення

1. Передача URI

```js
const { Sequelize } = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:') // sqlite
const sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname') // postgres
```

2. Передача окремих параметрів

sqlite:
```js
const sequelize = new Sequelize({
  dialect: 'sqlite',
  storage: 'path/to/database.sqlite' // шлях до файлу
});
```

mysql, mariadb, sqlite, postgres, mssql:
```js
const sequelize = new Sequelize('database', 'username', 'password', {
  dialect : "mysql",     // mysql, mariadb, sqlite, postgres, mssql
  host    : "localhost",
  port    : "1433"
});
```


### Тестування підключення

```js
try {
  await sequelize.authenticate();
  console.log('Підключення до БД здійснено успішно.');
} catch (error) {
  console.error('Помилка підключення до БД:', error);
}
```


### Закриття підключення

Sequelize автоматично підтримує підключення відкритим і використовує його для
усіх запитів. Закрити підключення:
```js
sequelize.close();
```


### Логування

За замовчуванням Sequelize виводить в консоль усі запити, які виконує. При
створенні об'єкту підключення цю поведінку можна змінити, передавши в
конструктор об'єкт з опціями. У функцію передається два параметри: 1й - сам
запит, 2й - об'єкт підключення.

```js
const sequelize = new Sequelize('sqlite::memory:', {
  // одне зі значень на вибір:
  logging: console.log,                  // за замовчуванням, показує 1й параметр лог-функції
  logging: (...msg) => console.log(msg), // показати усі параметри
  logging: false,                        // відключити логування
  logging: msg => logger.debug(msg),     // використовувати кастомний logger (напр. Winston) з 1м параметром
  logging: logger.debug.bind(logger)     // використовувати кастомний logger (напр. Winston) з усіма параметрами
});
```


Моделі
--------------------------------------------------------------------------------

Модель є абстакцією, яка представляє таблицю в БД. Містить дані про ім'я
таблиці, колонки, типи даних, які там зберігаються.


### Оголошення моделей

Після створення моделі вона стає доступною по імені через
sequelize.models.ім'я_моделі


#### метод sequelize.define(modelName, attributes, options)

Під капотом цей метод викликає Model.init().

```js
const { Sequelize, DataTypes } = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:');

const User = sequelize.define('User', {
  firstName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  lastName: {
    type: DataTypes.STRING
  }
}, {
  // тут опції
});

// sequelize.define повертає модель
console.log(User === sequelize.models.User); // true
```


#### наслідування класу Model і виклик методу init(attributes, options)

```js
const { Sequelize, DataTypes, Model } = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:');

class User extends Model {}

User.init({
  firstName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  lastName: {
    type: DataTypes.STRING
  }
}, {
  // тут опції
  sequelize,        // потрібно передати екземпляр підключення
  modelName: 'User' // тут потрібно вказувати ім'я моделі
});

console.log(User === sequelize.models.User); // true
```

#### Особливості оголошення моделей

Sequelize через Model.init() для кожного атрибуту (назва колонки) додає
відповідні гетер і сетер, тому, якщо в модель (а вона є JS-класом) додати
публічне статичне поле з іменем, яке буде рівним атрибуту, це поле затінить
гетер і сетер атрибута і зробить недоступним отримання даних.

Так не правильно:
```js
class User extends Model {
  id;
  otherPublicField;
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  }
}, { sequelize });

const user = new User({ id: 1 });
user.id; // undefined
```

Так правильно:
```js
class User extends Model {
  otherPublicField;
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  }
}, { sequelize });

const user = new User({ id: 1 });
user.id; // 1
```

В TypeScript ця проблема вирішується за допомогою ключового слова declare:
```js
class User extends Model {
  declare id: number;
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  }
}, { sequelize });

const user = new User({ id: 1 });
user.id; // 1
```


### Іменування таблиць

Ім'я моделі пишеться в однині, а ім'я таблиці автоматично перетворюється на
множину за правилами англійської мови (User -> users), але цю поведінку можна
змінити.


#### Заборона плюраризації таблиці

Заборонити утворювати множину для назви таблиці можна за допомогою властивості
freezeTableName, яку можна прописати або в конкретній моделі, або в об'єкті
підключення для усіх моделей одразу. Тоді таблиця буде називатися один-в-один як
і модель.

в моделі:
```js
sequelize.define('User', {…}, {
  freezeTableName: true
});
```

в об'єкті підключення:
```js
const sequelize = new Sequelize('sqlite::memory:', {
  define: {
    freezeTableName: true
  }
});
```


#### Явне вказування назви таблиці

```js
sequelize.define('User', {…}, // модель User
{
  tableName: 'Employees'      // таблиця Employees
});
```


### Синхронізація моделі з БД

```js
User.sync()                // створює таблицю, якщо її нема. Якщо є - не робить нічого.
User.sync({ force: true }) // видаляє таблицю, якщо вона є. Створює нову таблицю.
User.sync({ alter: true }) // приводить таблицю у відповідність до моделі.
```

приклади:
```js
await User.sync({ force: true });      // синхроніхація конкретної таблиці
await sequelize.sync({ force: true }); // синхронізація всіх таблиць
```


### Видалення таблиць

```js
await User.drop();      // видалення конкретної таблиці
await sequelize.drop(); // видалення всіх таблиць
```


### Безпечне видалення таблиці

```js
// видалення таблиці, тільки якщо вона закінчується на "_test"
sequelize.sync({ force: true, match: /_test$/ });
```


### Часові мітки

Крім власне полів моделі в таблиці будуть створюватися два додаткових поля:
createdAt та updatedAt, які матимуть тип datetime і вказуватимуть на дату
створення/модифікації таблиці. Якщо ці поля не потрібні, треба задати параметр
timestamps або в оголошенні об'єкту підключення (для всіх моделей), або у
конкнетній моделі в її класі.

в оголошенні об'єкту підключення:
```js
const Sequelize = require("sequelize");
const sequelize = new Sequelize("usersdb", "root", "123456", {
  dialect : "mysql",
  host    : "localhost",
  define  : {
    timestamps: false
  }
});
```

в моделі:
```js
sequelize.define('User', {…}, {
  timestamps: false
});
```

також можливо відключити тільки одну колонку, або дати кастомне ім'я:
```js
class Foo extends Model {}
Foo.init({…}, {
  sequelize,
  timestamps : true,
  createdAt  : false,
  updatedAt  : 'updateTimestamp'
});
```


### Короткий синтаксис

Якщо в стовпці вказується лише тип даних, синтаксис можна скоротити:
```js
// стандартне оголошення
sequelize.define('User', {
  name: {
    type: DataTypes.STRING
  }
});

// скорочене оголошення
sequelize.define('User', {
  name: DataTypes.STRING
});
```


### Значення за замовчуванням

За замовчуванням, якщо значення не було вказане, воно буде рівним NULL, або
дефолтним, якщо вказане дефолтне значення:
```js
sequelize.define('User', {
  name: {
    type: DataTypes.STRING,
    defaultValue: "John Doe"
  },
  lastLogin: {
    defaultValue: DataTypes.NOW
  }
});
```


### Типи даних

Підключення вбудованих типів даних:
```js
const { DataTypes } = require("sequelize");
```


#### Рядки:

```js
DataTypes.STRING             // VARCHAR(255)
DataTypes.STRING(1234)       // VARCHAR(1234)
DataTypes.STRING.BINARY      // VARCHAR BINARY
DataTypes.TEXT               // TEXT
DataTypes.TEXT('tiny')       // TINYTEXT
DataTypes.CITEXT             // CITEXT          тільки PostgreSQL/SQLite
DataTypes.TSVECTOR           // TSVECTOR        тільки PostgreSQL
```


#### Логічний тип:

```js
DataTypes.BOOLEAN            // TINYINT(1)
```


#### Числа:

```js
DataTypes.INTEGER            // INTEGER
DataTypes.BIGINT             // BIGINT
DataTypes.BIGINT(11)         // BIGINT(11)

DataTypes.FLOAT              // FLOAT
DataTypes.FLOAT(11)          // FLOAT(11)
DataTypes.FLOAT(11, 10)      // FLOAT(11,10)

DataTypes.REAL               // REAL            тільки PostgreSQL
DataTypes.REAL(11)           // REAL(11)        тільки PostgreSQL
DataTypes.REAL(11, 12)       // REAL(11,12)     тільки PostgreSQL

DataTypes.DOUBLE             // DOUBLE
DataTypes.DOUBLE(11)         // DOUBLE(11)
DataTypes.DOUBLE(11, 10)     // DOUBLE(11,10)

DataTypes.DECIMAL            // DECIMAL
DataTypes.DECIMAL(10, 2)     // DECIMAL(10,2)
```


#### Unsigned & Zerofill числа - тільки MySQL/MariaDB

В MySQL/MariaDB числові типи INTEGER, BIGINT, FLOAT і DOUBLE можуть бути
позначені як unsigned або zerofill (або одночасно і тим, і тим):

```js
DataTypes.INTEGER.UNSIGNED
DataTypes.INTEGER.ZEROFILL
DataTypes.INTEGER.UNSIGNED.ZEROFILL
// You can also specify the size i.e. INTEGER(10) instead of simply INTEGER
// Same for BIGINT, FLOAT and DOUBLE
```


#### Дати:

```js
DataTypes.DATE     // DATETIME для mysql/sqlite, TIMESTAMP з TIME ZONE для postgres
DataTypes.DATE(6)  // DATETIME(6) для mysql 5.6.4+. Fractional seconds support with up to 6 digits of precision
DataTypes.DATEONLY // DATE без часу
```


#### UUID:

тип UUID для PostgreSQL/SQLite, CHAR(36) для MySQL:
```js
{
  type: DataTypes.UUID,
  defaultValue: DataTypes.UUIDV4 // або DataTypes.UUIDV1
}
```


### Приклад налаштування таблиці з різними властивостями колонок

```js
const { Model, DataTypes, Deferrable } = require("sequelize");

class Foo extends Model {}
Foo.init({
  flag: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  myDate: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW
  },
  title: {
    type: DataTypes.STRING,
    allowNull: false
  },
  // Creating two objects with the same value will throw an error. The unique property can be either a
  // boolean, or a string. If you provide the same string for multiple columns, they will form a
  // composite unique key.
  uniqueOne: {
    type: DataTypes.STRING,
    unique: 'compositeIndex'
  },
  uniqueTwo: {
    type: DataTypes.INTEGER,
    unique: 'compositeIndex'
  },
  someUnique: {
    type: DataTypes.STRING,
    unique: true
  },
  identifier: {
    type: DataTypes.STRING,
    primaryKey: true
  },
  incrementMe: {
    type: DataTypes.INTEGER,
    autoIncrement: true
  },
  // зборити так, щоб ім'я властивості моделі != ім'я колонки таблиці
  fieldWithUnderscores: {
    type: DataTypes.STRING,
    field: 'field_with_underscores'
  },
  // зовнішні ключі
  bar_id: {
    type: DataTypes.INTEGER,
    references: {
      model: Bar,
      key: 'id',
      // With PostgreSQL, it is optionally possible to declare when to check the foreign key constraint, passing the Deferrable type.
      deferrable: Deferrable.INITIALLY_IMMEDIATE
      // Options:
      // - `Deferrable.INITIALLY_IMMEDIATE` - Immediately check the foreign key constraints
      // - `Deferrable.INITIALLY_DEFERRED` - Defer all foreign key constraint check to the end of a transaction
      // - `Deferrable.NOT` - Don't defer the checks at all (default) - This won't allow you to dynamically change the rule in a transaction
    }
  },
  // Комантарі до колонок в MySQL/MariaDB/PostgreSQL/MSSQL
  commentMe: {
    type: DataTypes.INTEGER,
    comment: 'This is a column name that has a comment'
  }
}, {
  sequelize,
  modelName: 'foo',
  // Це оголошення аналогічне до оголошення унікальності безпосередньо в колонці
  indexes: [
    {
      unique: true,
      fields: ['someUnique']
    }
  ]
});
```


### Моделі Sequelize - це класи JS

```js
class User extends Model {
  static classLevelMethod() {
    return 'foo';
  }
  instanceLevelMethod() {
    return 'bar';
  }
  getFullname() {
    return [this.firstname, this.lastname].join(' ');
  }
}
User.init({
  firstname: Sequelize.TEXT,
  lastname: Sequelize.TEXT
}, { sequelize });

console.log(User.classLevelMethod());                            // 'foo'
const user = User.build({ firstname: 'Jane', lastname: 'Doe' });
console.log(user.instanceLevelMethod());                         // 'bar'
console.log(user.getFullname());                                 // 'Jane Doe'
```


Екземпляри моделі
--------------------------------------------------------------------------------

### Створення екземпляру

Хоча модель є класом, створення екземпляру здійснюється за допомогою метода
Model.build(), а не new Model(). Метод Model.build() є синхронним, не взаємодіє
з БД, а тільки створює екземпляр. Для збереження використовується метод
instance.save(). Метод instance.save() оптимізований таким чином, що він
зберігає тільки змінені поля. Якщо змінених полів нема, запиту до БД не
відбудеться, відбудеться проміс, який одразу завершиться.


```js
const jane = User.build({ name: "Jane" }); // створити, але не зберігати в БД
console.log(jane instanceof User);         // true
console.log(jane.name);                    // "Jane"
await jane.save();                         // зберегти в БД
```


### Model.create() = Model.build() + instance.save()

```js
const jane = await User.create({ name: "Jane" });
```


### Логування екземплярів

Спроба використати console.log покаже багато сміття, тому для показу екземпляру
краще використовувати метод instance.toJSON():
```js
const jane = await User.create({ name: "Jane" });
console.log(jane.toJSON());                 // так або
console.log(JSON.stringify(jane, null, 4)); // так
```

### Значення за замовчуванням

Метод Model.build() додає значення за замовчуванням моделі в її екземпляр:
```js
const { Sequelize, Model, DataTypes } = require("sequelize");
const sequelize = new Sequelize("sqlite::memory:");

const User = sequelize.define("user", {
  name: DataTypes.TEXT,
  favoriteColor: {
    type: DataTypes.TEXT,
    defaultValue: 'green'
  },
});

(async () => {
  await sequelize.sync({ force: true });
  const jane = User.build({ name: "Jane" });
  console.log(jane.favoriteColor); // "green"
})();
```


### Оновлення екземпляру

Після внесення змін в екземпляр потрібно зберегти дані в БД:
```js
const jane = await User.create({ name: "Jane" }); // створити і зберети в БД
jane.name = "Ada";                                // переприсвоїти, в БД залишиться старе значення
await jane.save();                                // зберегти зміни в БД
```

Для оновлення кількох полів використовуються set() + save():
```js
const jane = await User.create({ name: "Jane" });
jane.set({
  name: "Ada",
  favoriteColor: "blue"
});
await jane.save();
```

Метод save() оновлює усі змінені поля. Якщо треба оновити якісь конкретні,
потрібно використовувати метод update(). Метод update() працює з БД, йому метод
save() не потрібен:
```js
const jane = await User.create({ name: "Jane" });
jane.favoriteColor = "blue";
await jane.update({ name: "Ada" }); // зміна не зачепить favoriteColor
```


### Видалення екземпляру з БД

```js
await jane.destroy();
```


### Перезавантаження екземпляру

Скидання значень екземпляру до тих, що записані в БД:
```js
const jane = await User.create({ name: "Jane" });
jane.name = "Ada";      // в БД залишається значення "Jane"
await jane.reload();
console.log(jane.name); // "Jane"
```


### Вибіркове збереження полів

```js
const jane = await User.create({ name: "Jane", favoriteColor: "green" });
jane.name = "Jane II";
jane.favoriteColor = "blue";
await jane.save({ fields: ['name'] });
console.log(jane.name);                // "Jane II"
console.log(jane.favoriteColor);       // "blue" - колір локального об'єкту, в БД залишилося значення "green"
await jane.reload();
console.log(jane.name);                // "Jane II"
console.log(jane.favoriteColor);       // "green"
```


### Збільшення/зменшення цифрових значень

Зміна більше ніж на 1 вимагає об'єкта з by, якщо треба змінити на 1, підійде 
instance.increment('attribute').
Результатом зміни в postgreSQL буде змінений екземпляр, якщо явно не вказана
опція { returning: false }, тоді результатом буде undefined. В інших діалектах
результат завжди undefined. Якщо потребен результат, можна викликати метод
reload().

```js
const jane = await User.create({ name: "Jane", age: 100 });
const incrementResult = await jane.increment('age', { by: 2 }); 
```


Також можна змінювати одразу кілька значень:
```js
const jane = await User.create({ name: "Jane", age: 100, cash: 5000 });
await jane.increment({
  'age': 2,
  'cash': 100
});

// якщо ці значення змінюються з однаковим кроком:
await jane.increment(['age', 'cash'], { by: 2 });
```


CRUD
--------------------------------------------------------------------------------

### INSERT

Model.create() =  Model.build() + instance.save():
```js
const jane = await User.create({ firstName: "Jane", lastName: "Doe" });
```


поля можна зберігати вибірково:
```js
const user = await User.create({
  username : 'alice123',         // це поле буде збережене в БД
  isAdmin  : true                // це поле не буде збережене в БД
}, { fields: ['username'] });
```


### SELECT

```js
const users = await User.findAll();
```


### Вибірка потрібних колонок для запиту

```js
// SELECT foo, bar FROM Model;
Model.findAll({
  attributes: ['foo', 'bar']
});
```


атрибути можуть бути перейменовані:
```js
// SELECT foo, bar AS baz, qux FROM Model;
Model.findAll({
  attributes: ['foo', ['bar', 'baz'], 'qux']
});

```


можна використовувати sequelize.fn для агрегації:
```js
// SELECT foo, COUNT(hats) AS n_hats, bar FROM Model;
Model.findAll({
  attributes: [
    'foo',
    [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats'],
    'bar'
  ]
});
```

При використанні агрегатних функцій потрібно давати псевдоніми, щоб мати
можливість звертатися до них з екземпляру моделі. Напр., instance.n_hats.


Якщо треба тільки додати агрегацію, щоб не перераховувати усі колонки, замість:
```js
Model.findAll({
  attributes: [
    'id', 'foo', 'bar', 'baz', 'qux', 'hats',
    [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats']
  ]
});
```

можна вжити:
```js
// SELECT id, foo, bar, baz, qux, hats, COUNT(hats) AS n_hats FROM Model;
Model.findAll({
  attributes: {
    include: [
      [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats']
    ]
  }
});
```


Не включати у вибірку деякі колонки:
```js
// SELECT id, foo, bar, qux FROM Model;
Model.findAll({
  attributes: { exclude: ['baz'] }
});
```


### WHERE

Якщо не вживаються оператори Op, Sequelize вважає, що в порівнянях
використовується рівність, а при кількох порівняннях - оператор AND:
```js
// SELECT * FROM post WHERE authorId = 2;
Post.findAll({
  where: {
    authorId: 2
  }
});

// те саме:
const { Op } = require("sequelize");
Post.findAll({
  where: {
    authorId: {
      [Op.eq]: 2
    }
  }
});

// SELECT * FROM post WHERE authorId = 12 AND status = 'active';
Post.findAll({
  where: {
    authorId: 2,
    status: 'active'
  }
});

// те саме:
const { Op } = require("sequelize");
Post.findAll({
  where: {
    [Op.and]: [
      { authorId: 12 },
      { status: 'active' }
    ]
  }
});
```


#### Оператори Op

```js
const { Op } = require("sequelize");
Post.findAll({
  where: {
    [Op.and]: [{ a: 5 }, { b: 6 }],            // (a = 5) AND (b = 6)
    [Op.or]: [{ a: 5 }, { b: 6 }],             // (a = 5) OR (b = 6)
    someAttribute: {
      // Basics
      [Op.eq]: 3,                              // = 3
      [Op.ne]: 20,                             // != 20
      [Op.is]: null,                           // IS NULL
      [Op.not]: true,                          // IS NOT TRUE
      [Op.or]: [5, 6],                         // (someAttribute = 5) OR (someAttribute = 6)

      // Using dialect specific column identifiers (PG in the following example):
      [Op.col]: 'user.organization_id',        // = "user"."organization_id"

      // Number comparisons
      [Op.gt]: 6,                              // > 6
      [Op.gte]: 6,                             // >= 6
      [Op.lt]: 10,                             // < 10
      [Op.lte]: 10,                            // <= 10
      [Op.between]: [6, 10],                   // BETWEEN 6 AND 10
      [Op.notBetween]: [11, 15],               // NOT BETWEEN 11 AND 15

      // Other operators

      [Op.all]: sequelize.literal('SELECT 1'), // > ALL (SELECT 1)

      [Op.in]: [1, 2],                         // IN [1, 2]
      [Op.notIn]: [1, 2],                      // NOT IN [1, 2]

      [Op.like]: '%hat',                       // LIKE '%hat'
      [Op.notLike]: '%hat',                    // NOT LIKE '%hat'
      [Op.startsWith]: 'hat',                  // LIKE 'hat%'
      [Op.endsWith]: 'hat',                    // LIKE '%hat'
      [Op.substring]: 'hat',                   // LIKE '%hat%'
      [Op.iLike]: '%hat',                      // ILIKE '%hat' (case insensitive) (PG only)
      [Op.notILike]: '%hat',                   // NOT ILIKE '%hat'  (PG only)
      [Op.regexp]: '^[h|a|t]',                 // REGEXP/~ '^[h|a|t]' (MySQL/PG only)
      [Op.notRegexp]: '^[h|a|t]',              // NOT REGEXP/!~ '^[h|a|t]' (MySQL/PG only)
      [Op.iRegexp]: '^[h|a|t]',                // ~* '^[h|a|t]' (PG only)
      [Op.notIRegexp]: '^[h|a|t]',             // !~* '^[h|a|t]' (PG only)

      [Op.any]: [2, 3],                        // ANY ARRAY[2, 3]::INTEGER (PG only)
      [Op.match]: Sequelize.fn('to_tsquery', 'fat & rat') // match text search for strings 'fat' and 'rat' (PG only)

      // In Postgres, Op.like/Op.iLike/Op.notLike can be combined to Op.any:
      [Op.like]: { [Op.any]: ['cat', 'hat'] }  // LIKE ANY ARRAY['cat', 'hat']

      // There are more postgres-only range operators, see below
      [Op.contains]: 2,            // @> '2'::integer  (PG range contains element operator)
      [Op.contains]: [1, 2],       // @> [1, 2)        (PG range contains range operator)
      [Op.contained]: [1, 2],      // <@ [1, 2)        (PG range is contained by operator)
      [Op.overlap]: [1, 2],        // && [1, 2)        (PG range overlap (have points in common) operator)
      [Op.adjacent]: [1, 2],       // -|- [1, 2)       (PG range is adjacent to operator)
      [Op.strictLeft]: [1, 2],     // << [1, 2)        (PG range strictly left of operator)
      [Op.strictRight]: [1, 2],    // >> [1, 2)        (PG range strictly right of operator)
      [Op.noExtendRight]: [1, 2],  // &< [1, 2)        (PG range does not extend to the right of operator)
      [Op.noExtendLeft]: [1, 2],   // &> [1, 2)        (PG range does not extend to the left of operator)
    }
  }
});
```


##### Приклад з Op.or

```js
// SELECT * FROM post WHERE authorId = 12 OR authorId = 13;
const { Op } = require("sequelize");
Post.findAll({
  where: {
    [Op.or]: [
      { authorId: 12 },
      { authorId: 13 }
    ]
  }
});

// SELECT * FROM post WHERE authorId = 12 OR authorId = 13;
const { Op } = require("sequelize");
Post.destroy({
  where: {
    authorId: {
      [Op.or]: [12, 13]
    }
  }
});
```


##### Скорочений синтаксис для Op.in

```js
// SELECT * FROM posts AS post WHERE post.id IN (1, 2, 3);
Post.findAll({
  where: {
    id: [1,2,3] // те саме, що і id: { [Op.in]: [1,2,3] }
  }
});
```


#### Комбінування логічних операторів

##### Op.and + Op.or

```js
const { Op } = require("sequelize");

Foo.findAll({
  where: {
    rank: {               // rank < 1000 OR rank IS NULL
      [Op.or]: {
        [Op.lt]: 1000,
        [Op.eq]: null
      }
    },
    {
      createdAt: {        // createdAt < [timestamp] AND createdAt > [timestamp]
        [Op.lt]: new Date(),
        [Op.gt]: new Date(new Date() - 24 * 60 * 60 * 1000)
      }
    },
    {
      [Op.or]: [          // title LIKE 'Boat%' OR description LIKE '%boat%'
        {
          title: {
            [Op.like]: 'Boat%'
          }
        },
        {
          description: {
            [Op.like]: '%boat%'
          }
        }
      ]
    }
  }
});
```

##### Op.not

```js
// SELECT *
// FROM `Projects`
// WHERE (
//   `Projects`.`name` = 'Some Project'
//   AND NOT (
//     `Projects`.`id` IN (1,2,3)
//     AND
//     `Projects`.`description` LIKE 'Hello%'
//   )
// )
Project.findAll({
  where: {
    name: 'Some Project',
    [Op.not]: [
      { id: [1,2,3] },
      {
        description: {
          [Op.like]: 'Hello%'
        }
      }
    ]
  }
});
```


#### Просунуті запити з функціями

```js
// SELECT * FROM posts AS post WHERE char_length("content") = 7
Post.findAll({
  where: sequelize.where(sequelize.fn('char_length', sequelize.col('content')), 7)
});
```

```js
// SELECT
// *
// FROM "posts" AS "post"
// WHERE (
//   char_length("content") = 7
//   OR
//   "post"."content" LIKE 'Hello%'
//   OR (
//     "post"."status" = 'draft'
//     AND
//     char_length("content") > 10
//   )
// )
Post.findAll({
  where: {
    [Op.or]: [
      sequelize.where(sequelize.fn('char_length', sequelize.col('content')), 7),
      {
        content: {
          [Op.like]: 'Hello%'
        }
      },
      {
        [Op.and]: [
          { status: 'draft' },
          sequelize.where(sequelize.fn('char_length', sequelize.col('content')), {
            [Op.gt]: 10
          })
        ]
      }
    ]
  }
});
```


### UPDATE

```js
await User.update({ lastName: "Doe" }, {
  where: {
    lastName: null
  }
});
```


### DELETE

```js
await User.destroy({
  where: {
    firstName: "Jane"
  }
});
```

Очистити усю таблицю:
```js
await User.destroy({
  truncate: true
});
```


### Створення гуртом

```js
const captains = await Captain.bulkCreate([
  { name: 'Jack Sparrow' },
  { name: 'Davy Jones' }
]);
```

За замовчуванням Model.bulkCreate(), на відміну від Model.сreate(), не проводить
валідацію. Щоб її явно увімкнути, треба визначити опцію validate: true, але це
зменшить продуктивність.

```js
const Foo = sequelize.define('foo', {
  bar: {
    type: DataTypes.TEXT,
    validate: {
      len: [4, 6]
    }
  }
});

// без валідації, помилки не буде
await Foo.bulkCreate([
  { name: 'abc123' },
  { name: 'name too long' }
]);

// валідація включена, буде помилка, в результаті буде створена порожня таблиця,
// жодні дані не запишуться
await Foo.bulkCreate([
  { name: 'abc123' },
  { name: 'name too long' }
], { validate: true });
```


Встановити обмеження, які стовпчики зберігати:
```js
await User.bulkCreate([
  { username: 'foo' },
  { username: 'bar', admin: true } // admin: true буде проігноровано
], { fields: ['username'] });
```


### Сортування і групування

#### Сортування DESC/ASC

```js
Subtask.findAll({
  order: [
    ['title', 'DESC'],

    // ??? Will order by max(age)
    sequelize.fn('max', sequelize.col('age')),
    // ??? Will order by max(age) DESC
    [sequelize.fn('max', sequelize.col('age')), 'DESC'],
    // ??? Will order by other function(`col1`, 12, 'lalala') DESC
    [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'],
    // ??? Will order an associated model's createdAt using the model name as the association's name.
    [Task, 'createdAt', 'DESC'],
    // ??? Will order through an associated model's createdAt using the model names as the associations' names.
    [Task, Project, 'createdAt', 'DESC'],
    // ??? Will order by an associated model's createdAt using the name of the association.
    ['Task', 'createdAt', 'DESC'],
    // ??? Will order by a nested associated model's createdAt using the names of the associations.
    ['Task', 'Project', 'createdAt', 'DESC'],
    // ??? Will order by an associated model's createdAt using an association object. (preferred method)
    [Subtask.associations.Task, 'createdAt', 'DESC'],
    // ??? Will order by a nested associated model's createdAt using association objects. (preferred method)
    [Subtask.associations.Task, Task.associations.Project, 'createdAt', 'DESC'],
    // ??? Will order by an associated model's createdAt using a simple association object.
    [{model: Task, as: 'Task'}, 'createdAt', 'DESC'],
    // ??? Will order by a nested associated model's createdAt simple association objects.
    [{model: Task, as: 'Task'}, {model: Project, as: 'Project'}, 'createdAt', 'DESC']
  ],
  // ??? Will order by max age descending
  order: sequelize.literal('max(age) DESC'),
  // ??? Will order by max age ascending assuming ascending is the default order when direction is omitted
  order: sequelize.fn('max', sequelize.col('age')),
  // ??? Will order by age ascending assuming ascending is the default order when direction is omitted
  order: sequelize.col('age'),
  // ??? Will order randomly based on the dialect (instead of fn('RAND') or fn('RANDOM'))
  order: sequelize.random()
});

Foo.findOne({
  order: [
    ['name'],
    ['username', 'DESC'],
    // ??? will return max(`age`)
    sequelize.fn('max', sequelize.col('age')),
    // ??? will return max(`age`) DESC
    [sequelize.fn('max', sequelize.col('age')), 'DESC'],
    // ??? will return otherfunction(`col1`, 12, 'lalala') DESC
    [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'],
    // ??? will return otherfunction(awesomefunction(`col`)) DESC, This nesting is potentially infinite!
    [sequelize.fn('otherfunction', sequelize.fn('awesomefunction', sequelize.col('col'))), 'DESC']
  ]
});
```


#### Групування

```js
// GROUP BY name
Project.findAll({ group: 'name' });
```


### Ліміти і сторінкування

```js
// Вивести 10 рядків
Project.findAll({ limit: 10 });

// Пропустити 8 рядків
Project.findAll({ offset: 8 });

// пропустити 5 рядків, показати наступні 5 рядків (6-10)
Project.findAll({ offset: 5, limit: 5 });
```


### Utility methods

#### count

Підрахунок кількості записів у базі:
```js
console.log(`There are ${await Project.count()} projects`);
const amount = await Project.count({
  where: {
    id: {
      [Op.gt]: 25
    }
  }
});
console.log(`There are ${amount} projects with an id greater than 25`);
```


#### max, min and sum

```js
// припустимо, в БД є три користувача з віком 5, 10, 40 років
await User.max('age'); // 40
await User.max('age', { where: { age: { [Op.lt]: 20 } } }); // 10
await User.min('age'); // 5
await User.min('age', { where: { age: { [Op.gt]: 5 } } }); // 10
await User.sum('age'); // 55
await User.sum('age', { where: { age: { [Op.gt]: 5 } } }); // 50
```


#### increment, decrement

```js
// припустимо, в БД є користувач з віком 10 років
await User.increment({age: 5}, { where: { id: 1 } }) // ++ -> 15
await User.increment({age: -5}, { where: { id: 1 } }) // -- -> 5
```


Пошукові методи
--------------------------------------------------------------------------------

Пошукові методи генерують запит SELECT. Результатом пошуку будуть екземпляри
класів, а не просто об'єкти JS. Це робиться завдяки тому, що Sequelize
автоматично обгортає відповідь БД у відповідні об'єкти екземпляра. Коли
результатів багато, це може бути не ефективним, тому, щоб вимкнути цю опцію,
потрібно передати { raw: true } як параметр методу пошуку.


### findAll

```js
const users = await User.findAll();
```


### findByPk

Пошук за первинним ключем:
```js
const project = await Project.findByPk(123);
if (project === null) {
  console.log('Not found!');
} else {
  console.log(project instanceof Project); // true
  // Its primary key is 123
}
```


### findOne

Повернення першого підходящого запису:
```js
const project = await Project.findOne({ where: { title: 'My Title' } });
if (project === null) {
  console.log('Not found!');
} else {
  console.log(project instanceof Project); // true
  console.log(project.title); // 'My Title'
}
```

### findOrCreate

Метод findOrCreate створить запис у таблиці, якщо він не знайде запис, що
відповідає параметрам запиту. В обох випадках він поверне екземпляр (або
знайдений, або створений) і логічне значення, яке вказує, чи цей екземпляр
було створено чи він вже існував.

```js
// припустимо, є БД з таблицею User(username, job)
const [user, created] = await User.findOrCreate({
  where: { username: 'sdepold' },
  defaults: {
    job: 'Technical Lead JavaScript'
  }
});
console.log(user.username); // 'sdepold'
console.log(user.job); // This may or may not be 'Technical Lead JavaScript'
console.log(created); // The boolean indicating whether this instance was just created
if (created) {
  console.log(user.job); // This will certainly be 'Technical Lead JavaScript'
}
```

### findAndCountAll

Метод findAndCountAll повертає об'єкт з двома властивостями:
  count - ціле число - загальна кількість записів, що відповідають запиту
  рядки - масив об'єктів - отримані записи


```js
const { count, rows } = await Project.findAndCountAll({
  where: {
    title: {
      [Op.like]: 'foo%'
    }
  },
  offset: 10,
  limit: 2
});
console.log(count);
console.log(rows);
```


Getters, Setters та віртуальні поля
--------------------------------------------------------------------------------

### Getter

В середині гетера не можна використовувати this.property, бо це викличе
безкінечну рекурсію. Натомість потрібно викликати this.getDataValue('property'):
```js
const User = sequelize.define('user', {
  username: {
    type: DataTypes.STRING,
    get() {
      const rawValue = this.getDataValue('username'); // this.username - помилка
      return rawValue ? rawValue.toUpperCase() : null;
    }
  }
});

const user = User.build({ username: 'SuperUser123' });
console.log(user.username);                            // 'SUPERUSER123'
console.log(user.getDataValue('username'));            // 'SuperUser123'
```

### Setter

Sequelize викликає сетер перед зверненням до бази, тобто БД навіть і не побачить
оригінальні дані, а тільки видозмінені сетером:
```js
const User = sequelize.define('user', {
  username: DataTypes.STRING,
  password: {
    type: DataTypes.STRING,
    set(value) {
      this.setDataValue('password', hash(this.username + value));
    }
  }
});

const user = User.build({ username: 'someone', password: 'NotSo§tr0ngP4$SW0RD!' });
console.log(user.password); // '7cfc84b8ea898bb72462e78b4643cfccd77e9f05678ec2ce78754147ba947acc'
console.log(user.getDataValue('password')); // '7cfc84b8ea898bb72462e78b4643cfccd77e9f05678ec2ce78754147ba947acc'
```


### Віртуальні поля

```js
const { DataTypes } = require("sequelize");

const User = sequelize.define('user', {
  firstName: DataTypes.TEXT,
  lastName: DataTypes.TEXT,
  fullName: {
    type: DataTypes.VIRTUAL,
    get() {
      return `${this.firstName} ${this.lastName}`;
    },
    set(value) {
      throw new Error('Do not try to set the `fullName` value!');
    }
  }
});

const user = await User.create({ firstName: 'John', lastName: 'Doe' });
console.log(user.fullName); // 'John Doe'
```

{raw: true} убиває доступ до віртуальних полів, оскільки віртуальні поля
вписуються у метадані а не в основний об'єкт;


Валідація та обмеження
--------------------------------------------------------------------------------

Валідація - це перевірка відповідності поля, яка здійснюється на рівні Sequelize
за допомогою JS. Якщо результат валідації негативний, запит не відбувається.
Обмеження - це правила в самій SQL (наприклад unique), не відповідність
запиту обмеженню викличе помилку в БД, яка буде передана в Sequelize.

allowNull: false є одночасно і валідацією, і обмеженням, бо якщо була спроба
встановити null, Sequelize згенерує помилку і запиту до БД не відбудеться, а
після sequelize.sunc() на колонку встановиться обмеження NOT NULL.

Валідація автоматично запускається на методах create, update, save. Також можна
вручну викликати метод instance.validate().


```js
sequelize.define('foo', {
  bar: {
    type: DataTypes.STRING,
    validate: {
      is: /^[a-z]+$/i,          // відповідність RegExp-виразу
      is: ["^[a-z]+$",'i'],     // відповідність RegExp-виразу
      not: /^[a-z]+$/i,         // не відповідність RegExp-виразу
      not: ["^[a-z]+$",'i'],    // не відповідність RegExp-виразу
      isEmail: true,            // перевірка на валідність пошти (foo@bar.com)
      isUrl: true,              // перевірка на валідність url (http://foo.com)
      isIP: true,               // перевірка на валідність IPv4 (129.89.23.1) або IPv6
      isIPv4: true,             // перевірка на валідність IPv4 (129.89.23.1)
      isIPv6: true,             // перевірка на валідність IPv6
      isAlpha: true,            // тільки букви
      isAlphanumeric: true,     // тільки цифри і букви
      isNumeric: true,          // тільки цифри
      isInt: true,              // тільки integers
      isFloat: true,            // тільки floating point numbers
      isDecimal: true,          // тільки цифри
      isLowercase: true,        // перевірка на нижній регістр
      isUppercase: true,        // перевірка на верхній регістр
      notNull: true,            // не допускає null
      isNull: true,             // тільки null
      notEmpty: true,           // не допускає пустий рядок
      equals: 'specific value', // допускає тільки специфічне значення
      contains: 'foo',          // вимагає певного підрядку
      notIn: [['foo', 'bar']],  // значення не з переліку
      isIn: [['foo', 'bar']],   // значення з переліку
      notContains: 'bar',       // не допускає певний підрядок
      len: [2,10],              // довжина від і до
      isUUID: 4,                // допускає тільки uuids
      isDate: true,             // перевірка на дату
      isAfter: "2011-11-05",    // перевірка на "після дати"
      isBefore: "2011-11-05",   // перевірка на "до дати"
      max: 23,                  // допустимі значення не більше за
      min: 23,                  // допустимі значення не менше за
      isCreditCard: true,       // перевірка на валідни кредитну карту

      // кастомні функції перевірки:
      isEven(value) {
        if (parseInt(value) % 2 !== 0) {
          throw new Error('Only even values are allowed!');
        }
      }
      isGreaterThanOtherField(value) {
        if (parseInt(value) <= parseInt(this.otherField)) {
          throw new Error('Bar must be greater than otherField.');
        }
      }
    }
  }
});
```

Якщо потрібно використати кастомне повідомлення про промилку валідації:
```js
isIn: {
  args: [['en', 'zh']],
  msg: "Must be English or Chinese"
}

isInt: {
  msg: "Must be an integer number of pennies"
}
```


Якщо на одному з полів спрацювала валідація allowNull: false, решта валідацій
будуть пропущені і виникне помилка ValidationError. Якщо на полі буде
встановлена валідація allowNull: true і значення буде NULL, вбудовані валідації
будуть пропущені, спрацюють тільки кастомні. Тому, якщо NULL є допустимим і є
інші валідації, вони повинні бути кастомні:
```js
class User extends Model {}
User.init({
  age: Sequelize.INTEGER,
  name: {
    type: DataTypes.STRING,
    allowNull: true,
    validate: {
      customValidator(value) {
        if (value === null && this.age !== 10) {
          throw new Error("name can't be null unless age is 10");
        }
      })
    }
  }
}, { sequelize });

```

Кастомізація помилки allowNull за допомогою валідатора notNull:
```js
class User extends Model {}
User.init({
  name: {
    type: DataTypes.STRING,
    allowNull: false,
    validate: {
      notNull: {
        msg: 'Please enter your name'
      }
    }
  }
}, { sequelize });
```


Також можна задати валідацію цілої моделі, яка відбудеться після валідацій
полів, наприклад для перевірки, чи всі поля вказані:
```js
class Place extends Model {}
Place.init({
  name: Sequelize.STRING,
  address: Sequelize.STRING,
  latitude: {
    type: DataTypes.INTEGER,
    validate: {
      min: -90,
      max: 90
    }
  },
  longitude: {
    type: DataTypes.INTEGER,
    validate: {
      min: -180,
      max: 180
    }
  },
}, {
  sequelize,
  validate: {
    bothCoordsOrNone() {
      if ((this.latitude === null) !== (this.longitude === null)) {
        throw new Error('Either both latitude and longitude, or neither!');
      }
    }
  }
})
```


Чисті SQL-запити
--------------------------------------------------------------------------------

Бувають ситуації, коли зручніше зробити запит SQL, ніж використовувати методи
Sequelize. Для цього використовується метод sequelize.query('query', {modelObj}),
який повертає два аргументи: результуючий масив і об'єкт з метаданими. Оскільки
відбувається прямий SQL-запит, метадані будуть різними залежно від діалекту.

```js
const [results, metadata] = await sequelize.query("UPDATE users SET y = 42 WHERE x = 12");
// Results will be an empty array and metadata will contain the number of affected rows.
```

Якщо доступ до метаданих не потрібен, потрібно вказати, як відформатувати
відповідь:
```js
const { QueryTypes } = require('sequelize');
const users = await sequelize.query("SELECT * FROM `users`", { type: QueryTypes.SELECT });
// We didn't need to destructure the result here - the results were returned directly
```

Другий аргумент sequelize.query('query', {modelObj}) - це модель. Якщо її
передати, повернутий результат буде екземпляром цієї моделі:
```js
const projects = await sequelize.query('SELECT * FROM projects', {
  model: Projects,
  mapToModel: true // pass true here if you have any mapped fields
});
// тепер кожен елемент масиву projects є екземпляром моделі Project
```

Приклад запиту:
```js
const { QueryTypes } = require('sequelize');
await sequelize.query('SELECT 1', {
  logging: console.log,
  plain: false, // якщо true - повертається тільки 1й запис, інакше - всі.
  raw: false, // якщо для запиту нема визначеної моделі, потрібно true
  type: QueryTypes.SELECT
});

// Note the second argument being null!
// Even if we declared a callee here, the raw: true would
// supersede and return a raw object.
console.log(await sequelize.query('SELECT * FROM projects', { raw: true }));
```


### Атрибути з крапками і вкладені властивості

Якщо у назві атрибуту є крапки, об'єкт-результат може бути різним у залежності
від опції nest: true.

без nest: true:
```js
const { QueryTypes } = require('sequelize');
const records = await sequelize.query('select 1 as `foo.bar.baz`', {
  type: QueryTypes.SELECT
});
console.log(JSON.stringify(records[0], null, 2));

// результат:
// {
//   "foo.bar.baz": 1
// }
```

з nest: true:
```js
const { QueryTypes } = require('sequelize');
const records = await sequelize.query('select 1 as `foo.bar.baz`', {
  nest: true,
  type: QueryTypes.SELECT
});
console.log(JSON.stringify(records[0], null, 2));

// результат:
// {
//   "foo": {
//     "bar": {
//       "baz": 1
//     }
//   }
// }
```


### Параметризація запитів

Оформлюється двома способами:
1. [] + ?
2. {} + :key


Значення з масиву підставляються замість ? у порядку появи ? у запиті:
```js
await sequelize.query(
  'SELECT * FROM projects WHERE status = ?',
  {
    replacements: ['active'],
    type: QueryTypes.SELECT
  }
);
```

Якщо не буде відповідного ключа у об'єкта, буде помилка:
```js
await sequelize.query(
  'SELECT * FROM projects WHERE status = :status',
  {
    replacements: { status: 'active' },
    type: QueryTypes.SELECT
  }
);
```

Array replacements will automatically be handled, the following query searches
for projects where the status matches an array of values:
```js
const { QueryTypes } = require('sequelize');

await sequelize.query(
  'SELECT * FROM projects WHERE status IN(:status)',
  {
    replacements: { status: ['active', 'inactive'] },
    type: QueryTypes.SELECT
  }
);
```

To use the wildcard operator %, append it to your replacement. The following
query matches users with names that start with 'ben':
```js
const { QueryTypes } = require('sequelize');

await sequelize.query(
  'SELECT * FROM users WHERE name LIKE :search_name',
  {
    replacements: { search_name: 'ben%' },
    type: QueryTypes.SELECT
  }
);
```


### Bind-параметр

Bind-параметр подібний до параметризації, але він не вставляється в SQL-запит, а
надсилається в БД окремо. Параметри прив'язуються до запита за допомогою чисел
$1, або буквенних ключів $key.

Якщо є масив, $1 прив'язується до першого його елемента (bind[0])
Якщо є об'єкт, $key прив'язується до object['key']. Ключ не може починатися з
цифри. $1 не буде валідним ключем, навіть якщо існує object['1'].
Для екранування $ треба використовувати $$.

```js
const { QueryTypes } = require('sequelize');

await sequelize.query(
  'SELECT *, "text with literal $$1 and literal $$status" as t FROM projects WHERE status = $1',
  {
    bind: ['active'],
    type: QueryTypes.SELECT
  }
);

await sequelize.query(
  'SELECT *, "text with literal $$1 and literal $$status" as t FROM projects WHERE status = $status',
  {
    bind: { status: 'active' },
    type: QueryTypes.SELECT
  }
);
```


Зв'язування таблиць
--------------------------------------------------------------------------------

A.hasOne(B, { … });
A.belongsTo(B, { … });
A.hasMany(B, { … });
A.belongsToMany(B, { through: 'C', … });



Paranoid
--------------------------------------------------------------------------------

